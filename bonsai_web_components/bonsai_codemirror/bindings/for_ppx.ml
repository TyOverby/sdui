[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Js_of_ocaml
open! Gen_js_api
open Custom_ojs_converter

module Promise = struct
  type ('a, 'e) t = Ojs.t

  let rec t_of_js : 'a 'e. (Ojs.t -> 'a) -> (Ojs.t -> 'e) -> Ojs.t -> ('a, 'e) t =
    fun (type __a __e) (__a_of_js : Ojs.t -> __a) (__e_of_js : Ojs.t -> __e) (x2 : Ojs.t) ->
    x2

  and t_to_js : 'a 'e. ('a -> Ojs.t) -> ('e -> Ojs.t) -> ('a, 'e) t -> Ojs.t =
    fun (type __a __e) (__a_to_js : __a -> Ojs.t) (__e_to_js : __e -> Ojs.t) (x1 : Ojs.t) ->
    x1
  ;;

  let create : (('a -> unit) -> ('e -> unit) -> unit) -> ('a, 'e) t =
    fun (x3 : ('a -> unit) -> ('e -> unit) -> unit) ->
    t_of_js
      Obj.magic
      Obj.magic
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "Promise")
         [| Ojs.fun_to_js 2 (fun (x4 : Ojs.t) (x6 : Ojs.t) ->
              x3
                (fun (x5 : 'a) -> ignore (Ojs.apply x4 [| Obj.magic x5 |]))
                (fun (x7 : 'e) -> ignore (Ojs.apply x6 [| Obj.magic x7 |])))
         |])
  ;;
end

module RegExp = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x11 : Ojs.t) -> x11
  and t_to_js : t -> Ojs.t = fun (x10 : Ojs.t) -> x10

  let create : string -> string option -> t =
    fun (x12 : string) (x13 : string option) ->
    t_of_js
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "RegExp")
         [| Ojs.string_to_js x12; Ojs.option_to_js Ojs.string_to_js x13 |])
  ;;
end

module Text = struct
  module Line = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x16 : Ojs.t) -> x16
    and t_to_js : t -> Ojs.t = fun (x15 : Ojs.t) -> x15

    let from : t -> int =
      fun (x17 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x17) "from")
    ;;

    let to_ : t -> int =
      fun (x18 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x18) "to")
    ;;

    let number : t -> int =
      fun (x19 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x19) "number")
    ;;

    let text : t -> string =
      fun (x20 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x20) "text")
    ;;

    let length : t -> int =
      fun (x21 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x21) "length")
    ;;
  end

  module Text_iterator = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x23 : Ojs.t) -> x23
    and t_to_js : t -> Ojs.t = fun (x22 : Ojs.t) -> x22

    let next : t -> ?skip:int -> unit -> t =
      fun (x27 : t) ?skip:(x24 : int option) () ->
      t_of_js
        (let x28 = t_to_js x27 in
         Ojs.call
           (Ojs.get_prop_ascii x28 "next")
           "apply"
           [| x28
            ; (let x25 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x24 with
                | Some x26 -> ignore (Ojs.call x25 "push" [| Ojs.int_to_js x26 |])
                | None -> ());
               x25)
           |])
    ;;

    let value : t -> string =
      fun (x29 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x29) "value")
    ;;

    let done_ : t -> bool =
      fun (x30 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x30) "done")
    ;;

    let line_break : t -> bool =
      fun (x31 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x31) "lineBreak")
    ;;
  end

  module Text = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x33 : Ojs.t) -> x33
    and t_to_js : t -> Ojs.t = fun (x32 : Ojs.t) -> x32

    let length : t -> int =
      fun (x34 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x34) "length")
    ;;

    let lines : t -> int =
      fun (x35 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x35) "lines")
    ;;

    let line_at : t -> int -> Line.t =
      fun (x37 : t) (x36 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x37) "lineAt" [| Ojs.int_to_js x36 |])
    ;;

    let line : t -> int -> Line.t =
      fun (x39 : t) (x38 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x39) "line" [| Ojs.int_to_js x38 |])
    ;;

    let replace : t -> from:int -> to_:int -> with_:t -> t =
      fun (x43 : t) ~from:(x40 : int) ~to_:(x41 : int) ~with_:(x42 : t) ->
      t_of_js
        (Ojs.call
           (t_to_js x43)
           "replace"
           [| Ojs.int_to_js x40; Ojs.int_to_js x41; t_to_js x42 |])
    ;;

    let append : t -> t -> t =
      fun (x45 : t) (x44 : t) ->
      t_of_js (Ojs.call (t_to_js x45) "append" [| t_to_js x44 |])
    ;;

    let slice : t -> from:int -> ?to_:int -> unit -> t =
      fun (x50 : t) ~from:(x46 : int) ?to_:(x47 : int option) () ->
      t_of_js
        (let x51 = t_to_js x50 in
         Ojs.call
           (Ojs.get_prop_ascii x51 "slice")
           "apply"
           [| x51
            ; (let x48 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x48 "push" [| Ojs.int_to_js x46 |]);
               (match x47 with
                | Some x49 -> ignore (Ojs.call x48 "push" [| Ojs.int_to_js x49 |])
                | None -> ());
               x48)
           |])
    ;;

    let slice_string : t -> from:int -> ?to_:int -> ?line_sep:string -> unit -> string =
      fun (x58 : t)
        ~from:(x52 : int)
        ?to_:(x53 : int option)
        ?line_sep:(x54 : string option)
        () ->
      Ojs.string_of_js
        (let x59 = t_to_js x58 in
         Ojs.call
           (Ojs.get_prop_ascii x59 "sliceString")
           "apply"
           [| x59
            ; (let x55 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x55 "push" [| Ojs.int_to_js x52 |]);
               (match x53 with
                | Some x57 -> ignore (Ojs.call x55 "push" [| Ojs.int_to_js x57 |])
                | None -> ());
               (match x54 with
                | Some x56 -> ignore (Ojs.call x55 "push" [| Ojs.string_to_js x56 |])
                | None -> ());
               x55)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x61 : t) (x60 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x61) "eq" [| t_to_js x60 |])
    ;;

    let iter : t -> ?dir:int -> unit -> Text_iterator.t =
      fun (x65 : t) ?dir:(x62 : int option) () ->
      Text_iterator.t_of_js
        (let x66 = t_to_js x65 in
         Ojs.call
           (Ojs.get_prop_ascii x66 "iter")
           "apply"
           [| x66
            ; (let x63 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x62 with
                | Some x64 -> ignore (Ojs.call x63 "push" [| Ojs.int_to_js x64 |])
                | None -> ());
               x63)
           |])
    ;;

    let iter_range : t -> from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x71 : t) ~from:(x67 : int) ?to_:(x68 : int option) () ->
      Text_iterator.t_of_js
        (let x72 = t_to_js x71 in
         Ojs.call
           (Ojs.get_prop_ascii x72 "iterRange")
           "apply"
           [| x72
            ; (let x69 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x69 "push" [| Ojs.int_to_js x67 |]);
               (match x68 with
                | Some x70 -> ignore (Ojs.call x69 "push" [| Ojs.int_to_js x70 |])
                | None -> ());
               x69)
           |])
    ;;

    let to_json : t -> string list =
      fun (x73 : t) ->
      Ojs.list_of_js Ojs.string_of_js (Ojs.call (t_to_js x73) "toJSON" [||])
    ;;

    let of_ : string list -> t =
      fun (x75 : string list) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.list_to_js Ojs.string_to_js x75 |])
    ;;

    let of_array : string array -> t =
      fun (x77 : string array) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.array_to_js Ojs.string_to_js x77 |])
    ;;

    let empty : t =
      t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "empty")
    ;;
  end

  let count_column : string -> n:int -> tab_size:int -> int =
    fun (x81 : string) ~n:(x79 : int) ~tab_size:(x80 : int) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.string_to_js x81)
         "countColumn"
         [| Ojs.int_to_js x79; Ojs.int_to_js x80 |])
  ;;

  module Offset_and_left_over = struct
    type t =
      { offset : int
      ; left_over : int
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x83 : Ojs.t) ->
      { offset = Ojs.int_of_js (Ojs.get_prop_ascii x83 "offset")
      ; left_over = Ojs.int_of_js (Ojs.get_prop_ascii x83 "leftOver")
      }

    and t_to_js : t -> Ojs.t =
      fun (x82 : t) ->
      Ojs.obj
        [| "offset", Ojs.int_to_js x82.offset; "leftOver", Ojs.int_to_js x82.left_over |]
    ;;
  end

  let find_column : string -> n:int -> col:int -> tab_size:int -> Offset_and_left_over.t =
    fun (x87 : string) ~n:(x84 : int) ~col:(x85 : int) ~tab_size:(x86 : int) ->
    Offset_and_left_over.t_of_js
      (Ojs.call
         (Ojs.string_to_js x87)
         "findColumn"
         [| Ojs.int_to_js x84; Ojs.int_to_js x85; Ojs.int_to_js x86 |])
  ;;

  let code_point_at : string -> int -> int =
    fun (x89 : string) (x88 : int) ->
    Ojs.int_of_js (Ojs.call (Ojs.string_to_js x89) "codePointAt" [| Ojs.int_to_js x88 |])
  ;;

  let from_code_point : int -> string =
    fun (x90 : int) ->
    Ojs.string_of_js (Ojs.call (Ojs.int_to_js x90) "fromCodePoint" [||])
  ;;

  let code_point_size : int -> int =
    fun (x91 : int) -> Ojs.int_of_js (Ojs.call (Ojs.int_to_js x91) "codePointSize" [||])
  ;;

  let find_cluster_break : string -> int -> ?forward:bool -> unit -> int =
    fun (x96 : string) (x92 : int) ?forward:(x93 : bool option) () ->
    Ojs.int_of_js
      (let x97 = Ojs.string_to_js x96 in
       Ojs.call
         (Ojs.get_prop_ascii x97 "findClusterBreak")
         "apply"
         [| x97
          ; (let x94 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore (Ojs.call x94 "push" [| Ojs.int_to_js x92 |]);
             (match x93 with
              | Some x95 -> ignore (Ojs.call x94 "push" [| Ojs.bool_to_js x95 |])
              | None -> ());
             x94)
         |])
  ;;
end

module State = struct
  module Extension = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x99 : Ojs.t) -> x99
    and t_to_js : t -> Ojs.t = fun (x98 : Ojs.t) -> x98

    let of_list : t list -> t =
      fun (x100 : t list) -> t_of_js (Ojs.list_to_js t_to_js x100)
    ;;
  end

  module Editor_state_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x103 : Ojs.t) -> x103
    and t_to_js : t -> Ojs.t = fun (x102 : Ojs.t) -> x102

    let create : ?doc:string -> ?extensions:Extension.t list -> unit -> t =
      fun ?doc:(x104 : string option) ?extensions:(x105 : Extension.t list option) () ->
      let x106 = Ojs.empty_obj () in
      (match x104 with
       | Some x109 -> Ojs.set_prop_ascii x106 "doc" (Ojs.string_to_js x109)
       | None -> ());
      (match x105 with
       | Some x107 ->
         Ojs.set_prop_ascii x106 "extensions" (Ojs.list_to_js Extension.t_to_js x107)
       | None -> ());
      t_of_js x106
    ;;
  end

  type state_effect = Ojs.t

  let rec state_effect_of_js : Ojs.t -> state_effect = fun (x111 : Ojs.t) -> x111
  and state_effect_to_js : state_effect -> Ojs.t = fun (x110 : Ojs.t) -> x110

  module State_effect_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x113 : Ojs.t) -> x113

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x112 : Ojs.t) -> x112
    ;;

    let of_ : 'a t -> 'a -> state_effect =
      fun (x115 : 'a t) (x114 : 'a) ->
      state_effect_of_js (Ojs.call (t_to_js Obj.magic x115) "of" [| Obj.magic x114 |])
    ;;
  end

  module State_effect = struct
    type t = state_effect

    let rec t_of_js : Ojs.t -> t = fun (x118 : Ojs.t) -> state_effect_of_js x118
    and t_to_js : t -> Ojs.t = fun (x117 : state_effect) -> state_effect_to_js x117

    let reconfigure : Extension.t State_effect_type.t =
      State_effect_type.t_of_js
        Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "reconfigure")
    ;;
  end

  module Annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x121 : Ojs.t) -> x121
    and t_to_js : t -> Ojs.t = fun (x120 : Ojs.t) -> x120
  end

  module Effects_and_annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x123 : Ojs.t) -> x123
    and t_to_js : t -> Ojs.t = fun (x122 : Ojs.t) -> x122

    let create
      : ?effects:State_effect.t list -> ?annotations:Annotation.t list -> unit -> t
      =
      fun ?effects:(x124 : State_effect.t list option)
        ?annotations:(x125 : Annotation.t list option)
        () ->
      let x126 = Ojs.empty_obj () in
      (match x124 with
       | Some x129 ->
         Ojs.set_prop_ascii x126 "effects" (Ojs.list_to_js State_effect.t_to_js x129)
       | None -> ());
      (match x125 with
       | Some x127 ->
         Ojs.set_prop_ascii x126 "annotations" (Ojs.list_to_js Annotation.t_to_js x127)
       | None -> ());
      t_of_js x126
    ;;
  end

  type change_set = Ojs.t

  let rec change_set_of_js : Ojs.t -> change_set = fun (x132 : Ojs.t) -> x132
  and change_set_to_js : change_set -> Ojs.t = fun (x131 : Ojs.t) -> x131

  module Change_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x134 : Ojs.t) -> x134
    and t_to_js : t -> Ojs.t = fun (x133 : Ojs.t) -> x133

    let single : ?from:int -> ?to_:int -> ?insert:Text.Text.t -> unit -> t =
      fun ?from:(x135 : int option)
        ?to_:(x136 : int option)
        ?insert:(x137 : Text.Text.t option)
        () ->
      let x138 = Ojs.empty_obj () in
      (match x135 with
       | Some x141 -> Ojs.set_prop_ascii x138 "from" (Ojs.int_to_js x141)
       | None -> ());
      (match x136 with
       | Some x140 -> Ojs.set_prop_ascii x138 "to" (Ojs.int_to_js x140)
       | None -> ());
      (match x137 with
       | Some x139 -> Ojs.set_prop_ascii x138 "insert" (Text.Text.t_to_js x139)
       | None -> ());
      t_of_js x138
    ;;

    let change_set : change_set -> t =
      fun (x142 : change_set) -> t_of_js (change_set_to_js x142)
    ;;

    let many : t list -> t = fun (x143 : t list) -> t_of_js (Ojs.list_to_js t_to_js x143)
  end

  module Map_mode = struct
    type t =
      | Simple
      | TrackDel
      | TrackBefore
      | TrackAfter

    let rec t_of_js : Ojs.t -> t =
      fun (x146 : Ojs.t) ->
      let x147 = x146 in
      match Ojs.string_of_js x147 with
      | "Simple" -> Simple
      | "TrackDel" -> TrackDel
      | "TrackBefore" -> TrackBefore
      | "TrackAfter" -> TrackAfter
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x145 : t) ->
      match x145 with
      | Simple -> Ojs.string_to_js "Simple"
      | TrackDel -> Ojs.string_to_js "TrackDel"
      | TrackBefore -> Ojs.string_to_js "TrackBefore"
      | TrackAfter -> Ojs.string_to_js "TrackAfter"
    ;;
  end

  module Cursor_association = struct
    type t =
      | Left
      | None
      | Right

    let rec t_of_js : Ojs.t -> t =
      fun (x149 : Ojs.t) ->
      let x150 = x149 in
      match Ojs.int_of_js x150 with
      | -1 -> Left
      | 0 -> None
      | 1 -> Right
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x148 : t) ->
      match x148 with
      | Left -> Ojs.int_to_js (-1)
      | None -> Ojs.int_to_js 0
      | Right -> Ojs.int_to_js 1
    ;;
  end

  module Touches_range = struct
    type t =
      | True
      | False
      | Cover

    let rec t_of_js : Ojs.t -> t =
      fun (x152 : Ojs.t) ->
      let x153 = x152 in
      match Ojs.type_of x153 with
      | "string" ->
        (match Ojs.string_of_js x153 with
         | "cover" -> Cover
         | _ -> assert false)
      | "boolean" ->
        (match Ojs.bool_of_js x153 with
         | true -> True
         | false -> False)
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x151 : t) ->
      match x151 with
      | True -> Ojs.bool_to_js true
      | False -> Ojs.bool_to_js false
      | Cover -> Ojs.string_to_js "cover"
    ;;
  end

  module Change_desc = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x155 : Ojs.t) -> x155
    and t_to_js : t -> Ojs.t = fun (x154 : Ojs.t) -> x154

    let length : t -> int =
      fun (x156 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x156) "length")
    ;;

    let new_length : t -> int =
      fun (x157 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x157) "newLength")
    ;;

    let empty : t -> bool =
      fun (x158 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x158) "empty")
    ;;

    let iter_gaps : t -> f:(a:int -> b:int -> length:int -> unit) -> unit =
      fun (x163 : t) ~f:(x159 : a:int -> b:int -> length:int -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x163)
           "iterGaps"
           [| Ojs.fun_to_js 3 (fun (x160 : Ojs.t) (x161 : Ojs.t) (x162 : Ojs.t) ->
                x159
                  ~a:(Ojs.int_of_js x160)
                  ~b:(Ojs.int_of_js x161)
                  ~length:(Ojs.int_of_js x162))
           |])
    ;;

    let iter_changed_ranges
      : t -> f:(from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) -> unit
      =
      fun (x169 : t) ~f:(x164 : from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x169)
           "iterChangedRanges"
           [| Ojs.fun_to_js
                4
                (fun (x165 : Ojs.t) (x166 : Ojs.t) (x167 : Ojs.t) (x168 : Ojs.t) ->
                   x164
                     ~from_a:(Ojs.int_of_js x165)
                     ~to_a:(Ojs.int_of_js x166)
                     ~from_b:(Ojs.int_of_js x167)
                     ~to_b:(Ojs.int_of_js x168))
           |])
    ;;

    let inverted_desc : t -> t =
      fun (x170 : t) -> t_of_js (Ojs.get_prop_ascii (t_to_js x170) "invertedDesc")
    ;;

    let compose_desc : t -> t -> t =
      fun (x172 : t) (x171 : t) ->
      t_of_js (Ojs.call (t_to_js x172) "composeDesc" [| t_to_js x171 |])
    ;;

    let map_desc : t -> t -> ?before:bool -> unit -> t =
      fun (x177 : t) (x173 : t) ?before:(x174 : bool option) () ->
      t_of_js
        (let x178 = t_to_js x177 in
         Ojs.call
           (Ojs.get_prop_ascii x178 "mapDesc")
           "apply"
           [| x178
            ; (let x175 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x175 "push" [| t_to_js x173 |]);
               (match x174 with
                | Some x176 -> ignore (Ojs.call x175 "push" [| Ojs.bool_to_js x176 |])
                | None -> ());
               x175)
           |])
    ;;

    let map_pos : t -> int -> assoc:Cursor_association.t -> mode:Map_mode.t -> t =
      fun (x182 : t)
        (x179 : int)
        ~assoc:(x180 : Cursor_association.t)
        ~mode:(x181 : Map_mode.t) ->
      t_of_js
        (Ojs.call
           (t_to_js x182)
           "mapPos"
           [| Ojs.int_to_js x179
            ; Cursor_association.t_to_js x180
            ; Map_mode.t_to_js x181
           |])
    ;;

    let touches_range : t -> from:int -> ?to_:int -> unit -> Touches_range.t =
      fun (x187 : t) ~from:(x183 : int) ?to_:(x184 : int option) () ->
      Touches_range.t_of_js
        (let x188 = t_to_js x187 in
         Ojs.call
           (Ojs.get_prop_ascii x188 "touchesRange")
           "apply"
           [| x188
            ; (let x185 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x185 "push" [| Ojs.int_to_js x183 |]);
               (match x184 with
                | Some x186 -> ignore (Ojs.call x185 "push" [| Ojs.int_to_js x186 |])
                | None -> ());
               x185)
           |])
    ;;
  end

  module Selection_range = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x190 : Ojs.t) -> x190
    and t_to_js : t -> Ojs.t = fun (x189 : Ojs.t) -> x189

    let from : t -> int =
      fun (x191 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x191) "from")
    ;;

    let to_ : t -> int =
      fun (x192 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x192) "to")
    ;;

    let anchor : t -> int =
      fun (x193 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x193) "anchor")
    ;;

    let head : t -> int =
      fun (x194 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x194) "head")
    ;;

    let empty : t -> bool =
      fun (x195 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x195) "empty")
    ;;

    let assoc : t -> Cursor_association.t =
      fun (x196 : t) ->
      Cursor_association.t_of_js (Ojs.get_prop_ascii (t_to_js x196) "assoc")
    ;;

    let bidi_level : t -> int option =
      fun (x197 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x197) "bidiLevel")
    ;;

    let goal_column : t -> int option =
      fun (x199 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x199) "goalColumn")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x205 : t) (x201 : Change_desc.t) ?assoc:(x202 : Cursor_association.t option) () ->
      t_of_js
        (let x206 = t_to_js x205 in
         Ojs.call
           (Ojs.get_prop_ascii x206 "map")
           "apply"
           [| x206
            ; (let x203 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x203 "push" [| Change_desc.t_to_js x201 |]);
               (match x202 with
                | Some x204 ->
                  ignore (Ojs.call x203 "push" [| Cursor_association.t_to_js x204 |])
                | None -> ());
               x203)
           |])
    ;;

    let extend : t -> from:int -> ?to_:int -> unit -> t =
      fun (x211 : t) ~from:(x207 : int) ?to_:(x208 : int option) () ->
      t_of_js
        (let x212 = t_to_js x211 in
         Ojs.call
           (Ojs.get_prop_ascii x212 "extend")
           "apply"
           [| x212
            ; (let x209 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x209 "push" [| Ojs.int_to_js x207 |]);
               (match x208 with
                | Some x210 -> ignore (Ojs.call x209 "push" [| Ojs.int_to_js x210 |])
                | None -> ());
               x209)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x214 : t) (x213 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x214) "eq" [| t_to_js x213 |])
    ;;

    let to_json : t -> Ojs.t = fun (x215 : t) -> Ojs.call (t_to_js x215) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x216 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "SelectionRange")
           "fromJSON"
           [| x216 |])
    ;;
  end

  module Editor_selection = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x218 : Ojs.t) -> x218
    and t_to_js : t -> Ojs.t = fun (x217 : Ojs.t) -> x217

    let ranges : t -> Selection_range.t list =
      fun (x219 : t) ->
      Ojs.list_of_js Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x219) "ranges")
    ;;

    let main_index : t -> int =
      fun (x221 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x221) "mainIndex")
    ;;

    let main : t -> Selection_range.t =
      fun (x222 : t) -> Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x222) "main")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x227 : t) (x223 : Change_desc.t) ?assoc:(x224 : Cursor_association.t option) () ->
      t_of_js
        (let x228 = t_to_js x227 in
         Ojs.call
           (Ojs.get_prop_ascii x228 "map")
           "apply"
           [| x228
            ; (let x225 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x225 "push" [| Change_desc.t_to_js x223 |]);
               (match x224 with
                | Some x226 ->
                  ignore (Ojs.call x225 "push" [| Cursor_association.t_to_js x226 |])
                | None -> ());
               x225)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x230 : t) (x229 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x230) "eq" [| t_to_js x229 |])
    ;;

    let as_single : t -> t =
      fun (x231 : t) -> t_of_js (Ojs.call (t_to_js x231) "asSingle" [||])
    ;;

    let add_range : t -> Selection_range.t -> ?main:bool -> unit -> t =
      fun (x236 : t) (x232 : Selection_range.t) ?main:(x233 : bool option) () ->
      t_of_js
        (let x237 = t_to_js x236 in
         Ojs.call
           (Ojs.get_prop_ascii x237 "addRange")
           "apply"
           [| x237
            ; (let x234 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x234 "push" [| Selection_range.t_to_js x232 |]);
               (match x233 with
                | Some x235 -> ignore (Ojs.call x234 "push" [| Ojs.bool_to_js x235 |])
                | None -> ());
               x234)
           |])
    ;;

    let replace_range : Selection_range.t -> ?which:int -> unit -> t =
      fun (x241 : Selection_range.t) ?which:(x238 : int option) () ->
      t_of_js
        (let x242 = Selection_range.t_to_js x241 in
         Ojs.call
           (Ojs.get_prop_ascii x242 "replaceRange")
           "apply"
           [| x242
            ; (let x239 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x238 with
                | Some x240 -> ignore (Ojs.call x239 "push" [| Ojs.int_to_js x240 |])
                | None -> ());
               x239)
           |])
    ;;

    let to_json : t -> Ojs.t = fun (x243 : t) -> Ojs.call (t_to_js x243) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x244 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorSelection")
           "fromJSON"
           [| x244 |])
    ;;

    let single : anchor:int -> ?head:int -> unit -> t =
      fun ~anchor:(x245 : int) ?head:(x246 : int option) () ->
      t_of_js
        (let x249 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x249 "single")
           "apply"
           [| x249
            ; (let x247 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x247 "push" [| Ojs.int_to_js x245 |]);
               (match x246 with
                | Some x248 -> ignore (Ojs.call x247 "push" [| Ojs.int_to_js x248 |])
                | None -> ());
               x247)
           |])
    ;;

    let create : ranges:Selection_range.t list -> ?main_index:int -> unit -> t =
      fun ~ranges:(x250 : Selection_range.t list) ?main_index:(x251 : int option) () ->
      t_of_js
        (let x255 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x255 "create")
           "apply"
           [| x255
            ; (let x252 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore
                 (Ojs.call x252 "push" [| Ojs.list_to_js Selection_range.t_to_js x250 |]);
               (match x251 with
                | Some x253 -> ignore (Ojs.call x252 "push" [| Ojs.int_to_js x253 |])
                | None -> ());
               x252)
           |])
    ;;

    let cursor
      :  pos:int -> ?assoc:Cursor_association.t -> ?bidi_level:int -> ?goal_column:int
      -> unit -> Selection_range.t
      =
      fun ~pos:(x256 : int)
        ?assoc:(x257 : Cursor_association.t option)
        ?bidi_level:(x258 : int option)
        ?goal_column:(x259 : int option)
        () ->
      Selection_range.t_of_js
        (let x264 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x264 "cursor")
           "apply"
           [| x264
            ; (let x260 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x260 "push" [| Ojs.int_to_js x256 |]);
               (match x257 with
                | Some x263 ->
                  ignore (Ojs.call x260 "push" [| Cursor_association.t_to_js x263 |])
                | None -> ());
               (match x258 with
                | Some x262 -> ignore (Ojs.call x260 "push" [| Ojs.int_to_js x262 |])
                | None -> ());
               (match x259 with
                | Some x261 -> ignore (Ojs.call x260 "push" [| Ojs.int_to_js x261 |])
                | None -> ());
               x260)
           |])
    ;;

    let range : anchor:int -> head:int -> ?goal_column:int -> unit -> Selection_range.t =
      fun ~anchor:(x265 : int) ~head:(x266 : int) ?goal_column:(x267 : int option) () ->
      Selection_range.t_of_js
        (let x270 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x270 "range")
           "apply"
           [| x270
            ; (let x268 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x268 "push" [| Ojs.int_to_js x265 |]);
               ignore (Ojs.call x268 "push" [| Ojs.int_to_js x266 |]);
               (match x267 with
                | Some x269 -> ignore (Ojs.call x268 "push" [| Ojs.int_to_js x269 |])
                | None -> ());
               x268)
           |])
    ;;
  end

  module Change_set = struct
    type t = change_set

    let rec t_of_js : Ojs.t -> t = fun (x272 : Ojs.t) -> change_set_of_js x272
    and t_to_js : t -> Ojs.t = fun (x271 : change_set) -> change_set_to_js x271

    let iter_changes
      :  t
      -> f:
           (from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit)
      -> unit
      =
      fun (x279 : t)
        ~f:
          (x273 :
            from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit) ->
      ignore
        (Ojs.call
           (t_to_js x279)
           "iterChanges"
           [| Ojs.fun_to_js
                5
                (fun
                    (x274 : Ojs.t)
                    (x275 : Ojs.t)
                    (x276 : Ojs.t)
                    (x277 : Ojs.t)
                    (x278 : Ojs.t)
                  ->
                   x273
                     ~from_a:(Ojs.int_of_js x274)
                     ~to_a:(Ojs.int_of_js x275)
                     ~from_b:(Ojs.int_of_js x276)
                     ~to_b:(Ojs.int_of_js x277)
                     ~inserted:(Text.Text.t_of_js x278))
           |])
    ;;

    let desc : t -> Change_desc.t =
      fun (x280 : t) -> Change_desc.t_of_js (Ojs.get_prop_ascii (t_to_js x280) "desc")
    ;;
  end

  type editor_state = Ojs.t

  let rec editor_state_of_js : Ojs.t -> editor_state = fun (x282 : Ojs.t) -> x282
  and editor_state_to_js : editor_state -> Ojs.t = fun (x281 : Ojs.t) -> x281

  module Annotation_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x284 : Ojs.t) -> x284

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x283 : Ojs.t) -> x283
    ;;
  end

  module Transaction = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x286 : Ojs.t) -> x286
    and t_to_js : t -> Ojs.t = fun (x285 : Ojs.t) -> x285

    let start_state : t -> editor_state =
      fun (x287 : t) ->
      editor_state_of_js (Ojs.get_prop_ascii (t_to_js x287) "startState")
    ;;

    let changes : t -> Change_set.t =
      fun (x288 : t) -> Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x288) "changes")
    ;;

    let selection : t -> Editor_selection.t option =
      fun (x289 : t) ->
      Ojs.option_of_js
        Editor_selection.t_of_js
        (Ojs.get_prop_ascii (t_to_js x289) "selection")
    ;;

    let effects : t -> State_effect.t list =
      fun (x291 : t) ->
      Ojs.list_of_js State_effect.t_of_js (Ojs.get_prop_ascii (t_to_js x291) "effects")
    ;;

    let scroll_into_view : t -> bool =
      fun (x293 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x293) "scrollIntoView")
    ;;

    let new_doc : t -> Text.Text.t =
      fun (x294 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x294) "newDoc")
    ;;

    let new_selection : t -> Editor_selection.t =
      fun (x295 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x295) "newSelection")
    ;;

    let state : t -> editor_state =
      fun (x296 : t) -> editor_state_of_js (Ojs.get_prop_ascii (t_to_js x296) "state")
    ;;

    let annotation : t -> 'a Annotation_type.t -> 'a option =
      fun (x299 : t) (x297 : 'a Annotation_type.t) ->
      Ojs.option_of_js
        Obj.magic
        (Ojs.call
           (t_to_js x299)
           "annotation"
           [| Annotation_type.t_to_js Obj.magic x297 |])
    ;;

    let doc_changed : t -> bool =
      fun (x301 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x301) "docChanged")
    ;;

    let reconfigured : t -> bool =
      fun (x302 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x302) "reconfigured")
    ;;

    let time : int Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "time")
    ;;

    let user_event : string Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.string_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "userEvent")
    ;;

    let add_to_history : bool Annotation_type.t =
      Annotation_type.t_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "addToHistory")
    ;;
  end

  module State_field_config = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x307 : Ojs.t) -> x307

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x306 : Ojs.t) -> x306
    ;;

    let create
      :  create:(editor_state -> 'v) -> update:('v -> Transaction.t -> 'v)
      -> compare:('v -> 'v -> bool) option -> 'v t
      =
      fun ~create:(x308 : editor_state -> 'v)
        ~update:(x309 : 'v -> Transaction.t -> 'v)
        ~compare:(x310 : ('v -> 'v -> bool) option) ->
      let x311 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x311
        "create"
        (Ojs.fun_to_js 1 (fun (x318 : Ojs.t) ->
           Obj.magic (x308 (editor_state_of_js x318))));
      Ojs.set_prop_ascii
        x311
        "update"
        (Ojs.fun_to_js 2 (fun (x316 : Ojs.t) (x317 : Ojs.t) ->
           Obj.magic (x309 (Obj.magic x316) (Transaction.t_of_js x317))));
      Ojs.set_prop_ascii
        x311
        "compare"
        (Ojs.option_to_js
           (fun (x313 : 'v -> 'v -> bool) ->
             Ojs.fun_to_js 2 (fun (x314 : Ojs.t) (x315 : Ojs.t) ->
               Ojs.bool_to_js (x313 (Obj.magic x314) (Obj.magic x315))))
           x310);
      t_of_js Obj.magic x311
    ;;
  end

  module State_field = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x320 : Ojs.t) -> x320

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x319 : Ojs.t) -> x319
    ;;

    let extension : 'v t -> Extension.t =
      fun (x321 : 'v t) ->
      Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x321) "extension")
    ;;

    let define : config:'v State_field_config.t -> 'v t =
      fun ~config:(x323 : 'v State_field_config.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateField")
           "define"
           [| State_field_config.t_to_js Obj.magic x323 |])
    ;;
  end

  module Facet = struct
    type ('i, 'o) t = Ojs.t

    let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
      fun (type __i __o)
        (__i_of_js : Ojs.t -> __i)
        (__o_of_js : Ojs.t -> __o)
        (x327 : Ojs.t) ->
      x327

    and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
      fun (type __i __o)
        (__i_to_js : __i -> Ojs.t)
        (__o_to_js : __o -> Ojs.t)
        (x326 : Ojs.t) ->
      x326
    ;;

    type 'i multi_out = ('i, 'i list) t

    let rec multi_out_of_js : 'i. (Ojs.t -> 'i) -> Ojs.t -> 'i multi_out =
      fun (type __i) (__i_of_js : Ojs.t -> __i) (x332 : Ojs.t) ->
      t_of_js __i_of_js (fun (x334 : Ojs.t) -> Ojs.list_of_js __i_of_js x334) x332

    and multi_out_to_js : 'i. ('i -> Ojs.t) -> 'i multi_out -> Ojs.t =
      fun (type __i) (__i_to_js : __i -> Ojs.t) (x328 : (__i, __i list) t) ->
      t_to_js __i_to_js (fun (x330 : __i list) -> Ojs.list_to_js __i_to_js x330) x328
    ;;

    let of_ : ('i, 'o) t -> 'i With_conversion.t -> Extension.t =
      fun (x338 : ('i, 'o) t) (x336 : 'i With_conversion.t) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x338)
           "of"
           [| With_conversion.t_to_js Obj.magic x336 |])
    ;;

    module Dep = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x344 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x344

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x341 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x341
      ;;

      type t =
        | Doc : t
        | Selection : t

      let rec t_of_js : Ojs.t -> t =
        fun (x348 : Ojs.t) ->
        let x349 = x348 in
        match Ojs.string_of_js x349 with
        | "doc" -> Doc
        | "selection" -> Selection
        | _ -> assert false

      and t_to_js : t -> Ojs.t =
        fun (x347 : t) ->
        match x347 with
        | Doc -> Ojs.string_to_js "doc"
        | Selection -> Ojs.string_to_js "selection"
      ;;
    end

    let compute : ('i, 'o) t -> deps:Dep.t list -> get:(editor_state -> 'i) -> Extension.t
      =
      fun (x354 : ('i, 'o) t) ~deps:(x350 : Dep.t list) ~get:(x352 : editor_state -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x354)
           "compute"
           [| Ojs.list_to_js Dep.t_to_js x350
            ; Ojs.fun_to_js 1 (fun (x353 : Ojs.t) ->
                Obj.magic (x352 (editor_state_of_js x353)))
           |])
    ;;

    let from : ('i, 'o) t -> field:'t State_field.t -> get:(value:'t -> 'i) -> Extension.t
      =
      fun (x361 : ('i, 'o) t)
        ~field:(x357 : 't State_field.t)
        ~get:(x359 : value:'t -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x361)
           "from"
           [| State_field.t_to_js Obj.magic x357
            ; Ojs.fun_to_js 1 (fun (x360 : Ojs.t) ->
                Obj.magic (x359 ~value:(Obj.magic x360)))
           |])
    ;;

    module Config = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x367 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x367

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x364 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x364
      ;;

      type ('i, 'o) t = Ojs.t

      let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x371 : Ojs.t) ->
        x371

      and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x370 : Ojs.t) ->
        x370
      ;;

      let create
        :  combine:('i list -> 'o) -> ?compare:('o -> 'o -> bool)
        -> ?compareInput:('i -> 'i -> bool) -> ?static:bool
        -> ?enables:(('i, 'o) facet -> Extension.t) -> unit -> ('i, 'o) t
        =
        fun ~combine:(x372 : 'i list -> 'o)
          ?compare:(x373 : ('o -> 'o -> bool) option)
          ?compareInput:(x374 : ('i -> 'i -> bool) option)
          ?static:(x375 : bool option)
          ?enables:(x376 : (('i, 'o) facet -> Extension.t) option)
          () ->
        let x377 = Ojs.empty_obj () in
        Ojs.set_prop_ascii
          x377
          "combine"
          (Ojs.fun_to_js 1 (fun (x391 : Ojs.t) ->
             Obj.magic (x372 (Ojs.list_of_js Obj.magic x391))));
        (match x373 with
         | Some x388 ->
           Ojs.set_prop_ascii
             x377
             "compare"
             (Ojs.fun_to_js 2 (fun (x389 : Ojs.t) (x390 : Ojs.t) ->
                Ojs.bool_to_js (x388 (Obj.magic x389) (Obj.magic x390))))
         | None -> ());
        (match x374 with
         | Some x385 ->
           Ojs.set_prop_ascii
             x377
             "compareInput"
             (Ojs.fun_to_js 2 (fun (x386 : Ojs.t) (x387 : Ojs.t) ->
                Ojs.bool_to_js (x385 (Obj.magic x386) (Obj.magic x387))))
         | None -> ());
        (match x375 with
         | Some x384 -> Ojs.set_prop_ascii x377 "static" (Ojs.bool_to_js x384)
         | None -> ());
        (match x376 with
         | Some x380 ->
           Ojs.set_prop_ascii
             x377
             "enables"
             (Ojs.fun_to_js 1 (fun (x381 : Ojs.t) ->
                Extension.t_to_js (x380 (facet_of_js Obj.magic Obj.magic x381))))
         | None -> ());
        t_of_js Obj.magic Obj.magic x377
      ;;
    end

    let define : ('i, 'o) Config.t -> ('i, 'o) t =
      fun (x393 : ('i, 'o) Config.t) ->
      t_of_js
        Obj.magic
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Facet")
           "define"
           [| Config.t_to_js Obj.magic Obj.magic x393 |])
    ;;
  end

  module Char_category = struct
    type t =
      | Word
      | Space
      | Other

    let rec t_of_js : Ojs.t -> t =
      fun (x399 : Ojs.t) ->
      let x400 = x399 in
      match Ojs.string_of_js x400 with
      | "Word" -> Word
      | "Space" -> Space
      | "Other" -> Other
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x398 : t) ->
      match x398 with
      | Word -> Ojs.string_to_js "Word"
      | Space -> Ojs.string_to_js "Space"
      | Other -> Ojs.string_to_js "Other"
    ;;
  end

  module Change_filter_result = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x402 : Ojs.t) -> x402
    and t_to_js : t -> Ojs.t = fun (x401 : Ojs.t) -> x401

    let bool : bool -> t = fun (x403 : bool) -> t_of_js (Ojs.bool_to_js x403)

    let ranges : int list -> t =
      fun (x404 : int list) -> t_of_js (Ojs.list_to_js Ojs.int_to_js x404)
    ;;
  end

  module Transaction_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x407 : Ojs.t) -> x407
    and t_to_js : t -> Ojs.t = fun (x406 : Ojs.t) -> x406

    let create
      :  ?changes:Change_spec.t -> ?selection:Editor_selection.t
      -> ?effects:State_effect.t list -> ?annotations:Annotation.t list
      -> ?scroll_into_view:bool -> ?filter:bool -> ?sequential:bool -> unit -> t
      =
      fun ?changes:(x408 : Change_spec.t option)
        ?selection:(x409 : Editor_selection.t option)
        ?effects:(x410 : State_effect.t list option)
        ?annotations:(x411 : Annotation.t list option)
        ?scroll_into_view:(x412 : bool option)
        ?filter:(x413 : bool option)
        ?sequential:(x414 : bool option)
        () ->
      let x415 = Ojs.empty_obj () in
      (match x408 with
       | Some x424 -> Ojs.set_prop_ascii x415 "changes" (Change_spec.t_to_js x424)
       | None -> ());
      (match x409 with
       | Some x423 -> Ojs.set_prop_ascii x415 "selection" (Editor_selection.t_to_js x423)
       | None -> ());
      (match x410 with
       | Some x421 ->
         Ojs.set_prop_ascii x415 "effects" (Ojs.list_to_js State_effect.t_to_js x421)
       | None -> ());
      (match x411 with
       | Some x419 ->
         Ojs.set_prop_ascii x415 "annotations" (Ojs.list_to_js Annotation.t_to_js x419)
       | None -> ());
      (match x412 with
       | Some x418 -> Ojs.set_prop_ascii x415 "scrollIntoView" (Ojs.bool_to_js x418)
       | None -> ());
      (match x413 with
       | Some x417 -> Ojs.set_prop_ascii x415 "filter" (Ojs.bool_to_js x417)
       | None -> ());
      (match x414 with
       | Some x416 -> Ojs.set_prop_ascii x415 "sequential" (Ojs.bool_to_js x416)
       | None -> ());
      t_of_js x415
    ;;
  end

  module Compartment = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x426 : Ojs.t) -> x426
    and t_to_js : t -> Ojs.t = fun (x425 : Ojs.t) -> x425

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Compartment")
           [||])
    ;;

    let of_ : t -> Extension.t -> Extension.t =
      fun (x428 : t) (x427 : Extension.t) ->
      Extension.t_of_js (Ojs.call (t_to_js x428) "of" [| Extension.t_to_js x427 |])
    ;;

    let reconfigure : t -> Extension.t -> state_effect =
      fun (x430 : t) (x429 : Extension.t) ->
      state_effect_of_js
        (Ojs.call (t_to_js x430) "reconfigure" [| Extension.t_to_js x429 |])
    ;;

    let get : t -> editor_state -> Extension.t option =
      fun (x432 : t) (x431 : editor_state) ->
      Ojs.option_of_js
        Extension.t_of_js
        (Ojs.call (t_to_js x432) "get" [| editor_state_to_js x431 |])
    ;;
  end

  module Editor_state = struct
    type t = editor_state

    let rec t_of_js : Ojs.t -> t = fun (x435 : Ojs.t) -> editor_state_of_js x435
    and t_to_js : t -> Ojs.t = fun (x434 : editor_state) -> editor_state_to_js x434

    let doc : t -> Text.Text.t =
      fun (x436 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x436) "doc")
    ;;

    let selection : t -> Editor_selection.t =
      fun (x437 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x437) "selection")
    ;;

    let field : t -> 'a State_field.t -> ?require:bool -> unit -> 'a =
      fun (x443 : t) (x438 : 'a State_field.t) ?require:(x439 : bool option) () ->
      Obj.magic
        (let x444 = t_to_js x443 in
         Ojs.call
           (Ojs.get_prop_ascii x444 "field")
           "apply"
           [| x444
            ; (let x440 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x440 "push" [| State_field.t_to_js Obj.magic x438 |]);
               (match x439 with
                | Some x441 -> ignore (Ojs.call x440 "push" [| Ojs.bool_to_js x441 |])
                | None -> ());
               x440)
           |])
    ;;

    let update : t -> Transaction_spec.t list -> Transaction.t =
      fun (x448 : t) (x445 : Transaction_spec.t list) ->
      Transaction.t_of_js
        (let x449 = t_to_js x448 in
         Ojs.call
           (Ojs.get_prop_ascii x449 "update")
           "apply"
           [| x449
            ; (let x446 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               List.iter
                 (fun (x447 : Transaction_spec.t) ->
                   ignore (Ojs.call x446 "push" [| Transaction_spec.t_to_js x447 |]))
                 x445;
               x446)
           |])
    ;;

    let replace_selection : t -> Text.Text.t -> Transaction_spec.t =
      fun (x451 : t) (x450 : Text.Text.t) ->
      Transaction_spec.t_of_js
        (Ojs.call (t_to_js x451) "replaceSelection" [| Text.Text.t_to_js x450 |])
    ;;

    let change_by_range
      : t -> f:(Selection_range.t -> Transaction_spec.t) -> Transaction_spec.t
      =
      fun (x454 : t) ~f:(x452 : Selection_range.t -> Transaction_spec.t) ->
      Transaction_spec.t_of_js
        (Ojs.call
           (t_to_js x454)
           "changeByRange"
           [| Ojs.fun_to_js 1 (fun (x453 : Ojs.t) ->
                Transaction_spec.t_to_js (x452 (Selection_range.t_of_js x453)))
           |])
    ;;

    let changes : t -> Change_spec.t -> Change_set.t =
      fun (x456 : t) (x455 : Change_spec.t) ->
      Change_set.t_of_js
        (Ojs.call (t_to_js x456) "changes" [| Change_spec.t_to_js x455 |])
    ;;

    let to_text : t -> string -> Text.Text.t =
      fun (x458 : t) (x457 : string) ->
      Text.Text.t_of_js (Ojs.call (t_to_js x458) "toText" [| Ojs.string_to_js x457 |])
    ;;

    let slice_doc : t -> ?from:int -> ?to_:int -> unit -> string =
      fun (x464 : t) ?from:(x459 : int option) ?to_:(x460 : int option) () ->
      Ojs.string_of_js
        (let x465 = t_to_js x464 in
         Ojs.call
           (Ojs.get_prop_ascii x465 "sliceDoc")
           "apply"
           [| x465
            ; (let x461 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x459 with
                | Some x463 -> ignore (Ojs.call x461 "push" [| Ojs.int_to_js x463 |])
                | None -> ());
               (match x460 with
                | Some x462 -> ignore (Ojs.call x461 "push" [| Ojs.int_to_js x462 |])
                | None -> ());
               x461)
           |])
    ;;

    let facet : t -> ('i, 'o) Facet.t -> 'o =
      fun (x469 : t) (x466 : ('i, 'o) Facet.t) ->
      Obj.magic
        (Ojs.call (t_to_js x469) "facet" [| Facet.t_to_js Obj.magic Obj.magic x466 |])
    ;;

    let to_json : t -> Ojs.t = fun (x470 : t) -> Ojs.call (t_to_js x470) "toJSON" [||]

    let get_tab_size : t -> int =
      fun (x471 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x471) "tabSize")
    ;;

    let line_break : t -> string =
      fun (x472 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x472) "lineBreak")
    ;;

    let phrase : t -> string -> string =
      fun (x474 : t) (x473 : string) ->
      Ojs.string_of_js (Ojs.call (t_to_js x474) "phrase" [| Ojs.string_to_js x473 |])
    ;;

    let language_data_at : t -> name:string -> pos:int -> Ojs.t list =
      fun (x477 : t) ~name:(x475 : string) ~pos:(x476 : int) ->
      Ojs.list_of_js
        (fun (x478 : Ojs.t) -> x478)
        (Ojs.call
           (t_to_js x477)
           "languageDataAt"
           [| Ojs.string_to_js x475; Ojs.int_to_js x476 |])
    ;;

    let char_categorizer : t -> int -> string -> Char_category.t =
      fun (x481 : t) (x479 : int) (x480 : string) ->
      Char_category.t_of_js
        (Ojs.call
           (t_to_js x481)
           "charCategorizer"
           [| Ojs.int_to_js x479; Ojs.string_to_js x480 |])
    ;;

    let from_json
      : json:Ojs.t -> ?config:Editor_state_config.t -> ?fields:Ojs.t -> unit -> t
      =
      fun ~json:(x482 : Ojs.t)
        ?config:(x483 : Editor_state_config.t option)
        ?fields:(x484 : Ojs.t option)
        () ->
      t_of_js
        (let x488 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorState"
         in
         Ojs.call
           (Ojs.get_prop_ascii x488 "fromJSON")
           "apply"
           [| x488
            ; (let x485 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x485 "push" [| x482 |]);
               (match x483 with
                | Some x487 ->
                  ignore (Ojs.call x485 "push" [| Editor_state_config.t_to_js x487 |])
                | None -> ());
               (match x484 with
                | Some x486 -> ignore (Ojs.call x485 "push" [| x486 |])
                | None -> ());
               x485)
           |])
    ;;

    let create : Editor_state_config.t -> t =
      fun (x489 : Editor_state_config.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "create"
           [| Editor_state_config.t_to_js x489 |])
    ;;

    let allow_multiple_selections : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "allowMultipleSelections")
    ;;

    let tab_size : (int, int) Facet.t =
      Facet.t_of_js
        Ojs.int_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "tabSize")
    ;;

    let read_only : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "readOnly")
    ;;

    let line_separator : (string, string option) Facet.t =
      Facet.t_of_js
        Ojs.string_of_js
        (fun (x497 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x497)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "lineSeparator")
    ;;

    let phrases : Ojs.t Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x499 : Ojs.t) -> x499)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "phrases")
    ;;

    let language_data : (t -> int -> Ojs.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x500 : Ojs.t) (x501 : t) (x502 : int) ->
          Ojs.list_of_js
            (fun (x503 : Ojs.t) -> x503)
            (Ojs.apply x500 [| t_to_js x501; Ojs.int_to_js x502 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "languageData")
    ;;

    let change_filter : (Transaction.t -> Change_filter_result.t) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x504 : Ojs.t) (x505 : Transaction.t) ->
          Change_filter_result.t_of_js (Ojs.apply x504 [| Transaction.t_to_js x505 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "changeFilter")
    ;;

    let transaction_filter : (Transaction.t -> Transaction_spec.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x506 : Ojs.t) (x507 : Transaction.t) ->
          Ojs.list_of_js
            Transaction_spec.t_of_js
            (Ojs.apply x506 [| Transaction.t_to_js x507 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionFilter")
    ;;

    let transaction_extender : (Transaction.t -> Effects_and_annotation.t) Facet.multi_out
      =
      Facet.multi_out_of_js
        (fun (x509 : Ojs.t) (x510 : Transaction.t) ->
          Effects_and_annotation.t_of_js (Ojs.apply x509 [| Transaction.t_to_js x510 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionExtender")
    ;;
  end

  module Range = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x512 : Ojs.t) -> x512

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x511 : Ojs.t) -> x511
    ;;

    let from : 'v t -> int =
      fun (x513 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x513) "from")
    ;;

    let to_ : 'v t -> int =
      fun (x515 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x515) "to")
    ;;
  end

  module Range_set_update_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x518 : Ojs.t) -> x518

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x517 : Ojs.t) -> x517
    ;;

    let create
      :  add:'v Range.t list -> sort:bool
      -> filter:(from:int -> to_:int -> value:'v -> bool) option -> filter_from:int option
      -> filter_to:int option -> 'v t
      =
      fun ~add:(x519 : 'v Range.t list)
        ~sort:(x520 : bool)
        ~filter:(x521 : (from:int -> to_:int -> value:'v -> bool) option)
        ~filter_from:(x522 : int option)
        ~filter_to:(x523 : int option) ->
      let x524 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x524
        "add"
        (Ojs.list_to_js (fun (x532 : 'v Range.t) -> Range.t_to_js Obj.magic x532) x519);
      Ojs.set_prop_ascii x524 "sort" (Ojs.bool_to_js x520);
      Ojs.set_prop_ascii
        x524
        "filter"
        (Ojs.option_to_js
           (fun (x528 : from:int -> to_:int -> value:'v -> bool) ->
             Ojs.fun_to_js 3 (fun (x529 : Ojs.t) (x530 : Ojs.t) (x531 : Ojs.t) ->
               Ojs.bool_to_js
                 (x528
                    ~from:(Ojs.int_of_js x529)
                    ~to_:(Ojs.int_of_js x530)
                    ~value:(Obj.magic x531))))
           x521);
      Ojs.set_prop_ascii x524 "filterFrom" (Ojs.option_to_js Ojs.int_to_js x522);
      Ojs.set_prop_ascii x524 "filterTo" (Ojs.option_to_js Ojs.int_to_js x523);
      t_of_js Obj.magic x524
    ;;
  end

  module Range_set = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x535 : Ojs.t) -> x535

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x534 : Ojs.t) -> x534
    ;;

    let empty : 'v t =
      t_of_js
        Obj.magic
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "RangeSet")
           "empty")
    ;;

    let size : 'v t -> int =
      fun (x537 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x537) "size")
    ;;

    let update : 'v t -> update_spec:'v Range_set_update_spec.t -> 'v t =
      fun (x541 : 'v t) ~update_spec:(x539 : 'v Range_set_update_spec.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (t_to_js Obj.magic x541)
           "update"
           [| Range_set_update_spec.t_to_js Obj.magic x539 |])
    ;;

    let between
      :  'v t -> from:int -> to_:int -> f:(from:int -> to_:int -> value:'v -> bool option)
      -> unit
      =
      fun (x551 : 'v t)
        ~from:(x544 : int)
        ~to_:(x545 : int)
        ~f:(x546 : from:int -> to_:int -> value:'v -> bool option) ->
      ignore
        (Ojs.call
           (t_to_js Obj.magic x551)
           "between"
           [| Ojs.int_to_js x544
            ; Ojs.int_to_js x545
            ; Ojs.fun_to_js 3 (fun (x547 : Ojs.t) (x548 : Ojs.t) (x549 : Ojs.t) ->
                Ojs.option_to_js
                  Ojs.bool_to_js
                  (x546
                     ~from:(Ojs.int_of_js x547)
                     ~to_:(Ojs.int_of_js x548)
                     ~value:(Obj.magic x549)))
           |])
    ;;
  end

  module Prec = struct
    let fallback : Extension.t -> Extension.t =
      fun (x553 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "fallback"
           [| Extension.t_to_js x553 |])
    ;;

    let default : Extension.t -> Extension.t =
      fun (x554 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "default"
           [| Extension.t_to_js x554 |])
    ;;

    let extend : Extension.t -> Extension.t =
      fun (x555 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "extend"
           [| Extension.t_to_js x555 |])
    ;;

    let override : Extension.t -> Extension.t =
      fun (x556 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "override"
           [| Extension.t_to_js x556 |])
    ;;

    let high : Extension.t -> Extension.t =
      fun (x557 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "high"
           [| Extension.t_to_js x557 |])
    ;;
  end
end

module View = struct
  type editor_view = Ojs.t

  let rec editor_view_of_js : Ojs.t -> editor_view = fun (x559 : Ojs.t) -> x559
  and editor_view_to_js : editor_view -> Ojs.t = fun (x558 : Ojs.t) -> x558

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x561 : Ojs.t) -> x561
    and t_to_js : t -> Ojs.t = fun (x560 : Ojs.t) -> x560

    let create
      :  ?state:State.Editor_state.t
      -> ?dispatch:(State.Transaction.t -> editor_view -> unit) Callback.t
      -> ?scroll_to:State.State_effect.t -> unit -> t
      =
      fun ?state:(x562 : State.Editor_state.t option)
        ?dispatch:(x563 : (State.Transaction.t -> editor_view -> unit) Callback.t option)
        ?scroll_to:(x564 : State.State_effect.t option)
        () ->
      let x565 = Ojs.empty_obj () in
      (match x562 with
       | Some x571 -> Ojs.set_prop_ascii x565 "state" (State.Editor_state.t_to_js x571)
       | None -> ());
      (match x563 with
       | Some x567 ->
         Ojs.set_prop_ascii
           x565
           "dispatch"
           (Callback.t_to_js
              (fun (x568 : State.Transaction.t -> editor_view -> unit) ->
                Ojs.fun_to_js 2 (fun (x569 : Ojs.t) (x570 : Ojs.t) ->
                  x568 (State.Transaction.t_of_js x569) (editor_view_of_js x570)))
              x567)
       | None -> ());
      (match x564 with
       | Some x566 -> Ojs.set_prop_ascii x565 "scrollTo" (State.State_effect.t_to_js x566)
       | None -> ());
      t_of_js x565
    ;;
  end

  module View_update = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x573 : Ojs.t) -> x573
    and t_to_js : t -> Ojs.t = fun (x572 : Ojs.t) -> x572

    let changes : t -> State.Change_set.t =
      fun (x574 : t) ->
      State.Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x574) "changes")
    ;;

    let state : t -> State.Editor_state.t =
      fun (x575 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x575) "state")
    ;;

    let view : t -> editor_view =
      fun (x576 : t) -> editor_view_of_js (Ojs.get_prop_ascii (t_to_js x576) "view")
    ;;

    let viewport_changed : t -> bool =
      fun (x577 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x577) "viewportChanged")
    ;;

    let doc_changed : t -> bool =
      fun (x578 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x578) "docChanged")
    ;;
  end

  let highlight_special_chars : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightSpecialChars"
         [||])
  ;;

  let highlight_active_line : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLine"
         [||])
  ;;

  let placeholder : content:string -> State.Extension.t =
    fun ~content:(x579 : string) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "placeholder"
         [| Ojs.string_to_js x579 |])
  ;;

  module Draw_selection_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x581 : Ojs.t) -> x581
    and t_to_js : t -> Ojs.t = fun (x580 : Ojs.t) -> x580

    let create : ?cursor_blink_rate:float -> ?draw_range_cursor:bool -> unit -> t =
      fun ?cursor_blink_rate:(x582 : float option)
        ?draw_range_cursor:(x583 : bool option)
        () ->
      let x584 = Ojs.empty_obj () in
      (match x582 with
       | Some x586 -> Ojs.set_prop_ascii x584 "cursorBlinkRate" (Ojs.float_to_js x586)
       | None -> ());
      (match x583 with
       | Some x585 -> Ojs.set_prop_ascii x584 "drawRangeCursor" (Ojs.bool_to_js x585)
       | None -> ());
      t_of_js x584
    ;;
  end

  let draw_selection : ?config:Draw_selection_config.t -> unit -> State.Extension.t =
    fun ?config:(x587 : Draw_selection_config.t option) () ->
    State.Extension.t_of_js
      (let x590 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x590 "drawSelection")
         "apply"
         [| x590
          ; (let x588 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x587 with
              | Some x589 ->
                ignore (Ojs.call x588 "push" [| Draw_selection_config.t_to_js x589 |])
              | None -> ());
             x588)
         |])
  ;;

  module Widget_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x592 : Ojs.t) -> x592
    and t_to_js : t -> Ojs.t = fun (x591 : Ojs.t) -> x591

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "WidgetType")
           [||])
    ;;

    let set_to_dom : t -> (unit -> Ojs.t) -> unit =
      fun (x593 : t) (x594 : unit -> Ojs.t) ->
      Ojs.set_prop_ascii (t_to_js x593) "toDOM" (Ojs.fun_to_js 1 (fun _ -> x594 ()))
    ;;
  end

  module Decoration = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x596 : Ojs.t) -> x596
    and t_to_js : t -> Ojs.t = fun (x595 : Ojs.t) -> x595

    let range : t -> from:int -> to_:int -> t State.Range.t =
      fun (x599 : t) ~from:(x597 : int) ~to_:(x598 : int) ->
      State.Range.t_of_js
        t_of_js
        (Ojs.call (t_to_js x599) "range" [| Ojs.int_to_js x597; Ojs.int_to_js x598 |])
    ;;

    let set : t State.Range.t list -> sort:bool -> t State.Range_set.t =
      fun (x601 : t State.Range.t list) ~sort:(x604 : bool) ->
      State.Range_set.t_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "set"
           [| Ojs.list_to_js
                (fun (x602 : t State.Range.t) -> State.Range.t_to_js t_to_js x602)
                x601
            ; Ojs.bool_to_js x604
           |])
    ;;

    let none : t State.Range_set.t =
      State.Range_set.t_of_js
        t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "none")
    ;;

    module Mark_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x608 : Ojs.t) -> x608
      and t_to_js : t -> Ojs.t = fun (x607 : Ojs.t) -> x607

      let create
        :  ?inclusive:bool -> ?inclusive_start:bool -> ?inclusive_end:bool
        -> ?attributes:Ojs.t -> ?class_:string -> ?tag_name:string -> unit -> t
        =
        fun ?inclusive:(x609 : bool option)
          ?inclusive_start:(x610 : bool option)
          ?inclusive_end:(x611 : bool option)
          ?attributes:(x612 : Ojs.t option)
          ?class_:(x613 : string option)
          ?tag_name:(x614 : string option)
          () ->
        let x615 = Ojs.empty_obj () in
        (match x609 with
         | Some x621 -> Ojs.set_prop_ascii x615 "inclusive" (Ojs.bool_to_js x621)
         | None -> ());
        (match x610 with
         | Some x620 -> Ojs.set_prop_ascii x615 "inclusiveStart" (Ojs.bool_to_js x620)
         | None -> ());
        (match x611 with
         | Some x619 -> Ojs.set_prop_ascii x615 "inclusiveEnd" (Ojs.bool_to_js x619)
         | None -> ());
        (match x612 with
         | Some x618 -> Ojs.set_prop_ascii x615 "attributes" x618
         | None -> ());
        (match x613 with
         | Some x617 -> Ojs.set_prop_ascii x615 "class" (Ojs.string_to_js x617)
         | None -> ());
        (match x614 with
         | Some x616 -> Ojs.set_prop_ascii x615 "tagName" (Ojs.string_to_js x616)
         | None -> ());
        t_of_js x615
      ;;
    end

    let mark : Mark_spec.t -> t =
      fun (x622 : Mark_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "mark"
           [| Mark_spec.t_to_js x622 |])
    ;;

    module Widget_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x624 : Ojs.t) -> x624
      and t_to_js : t -> Ojs.t = fun (x623 : Ojs.t) -> x623

      let create
        :  widget:Widget_type.t -> ?side:int -> ?inline_order:bool -> ?block:bool -> unit
        -> t
        =
        fun ~widget:(x625 : Widget_type.t)
          ?side:(x626 : int option)
          ?inline_order:(x627 : bool option)
          ?block:(x628 : bool option)
          () ->
        let x629 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x629 "widget" (Widget_type.t_to_js x625);
        (match x626 with
         | Some x632 -> Ojs.set_prop_ascii x629 "side" (Ojs.int_to_js x632)
         | None -> ());
        (match x627 with
         | Some x631 -> Ojs.set_prop_ascii x629 "inlineOrder" (Ojs.bool_to_js x631)
         | None -> ());
        (match x628 with
         | Some x630 -> Ojs.set_prop_ascii x629 "block" (Ojs.bool_to_js x630)
         | None -> ());
        t_of_js x629
      ;;
    end

    let widget : Widget_spec.t -> t =
      fun (x633 : Widget_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "widget"
           [| Widget_spec.t_to_js x633 |])
    ;;

    module Replace_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x635 : Ojs.t) -> x635
      and t_to_js : t -> Ojs.t = fun (x634 : Ojs.t) -> x634

      let create
        :  ?widget:Widget_type.t -> ?inclusive:bool -> ?inclusive_start:bool
        -> ?inclusive_end:bool -> ?block:bool -> unit -> t
        =
        fun ?widget:(x636 : Widget_type.t option)
          ?inclusive:(x637 : bool option)
          ?inclusive_start:(x638 : bool option)
          ?inclusive_end:(x639 : bool option)
          ?block:(x640 : bool option)
          () ->
        let x641 = Ojs.empty_obj () in
        (match x636 with
         | Some x646 -> Ojs.set_prop_ascii x641 "widget" (Widget_type.t_to_js x646)
         | None -> ());
        (match x637 with
         | Some x645 -> Ojs.set_prop_ascii x641 "inclusive" (Ojs.bool_to_js x645)
         | None -> ());
        (match x638 with
         | Some x644 -> Ojs.set_prop_ascii x641 "inclusiveStart" (Ojs.bool_to_js x644)
         | None -> ());
        (match x639 with
         | Some x643 -> Ojs.set_prop_ascii x641 "inclusiveEnd" (Ojs.bool_to_js x643)
         | None -> ());
        (match x640 with
         | Some x642 -> Ojs.set_prop_ascii x641 "block" (Ojs.bool_to_js x642)
         | None -> ());
        t_of_js x641
      ;;
    end

    let replace : Replace_spec.t -> t =
      fun (x647 : Replace_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "replace"
           [| Replace_spec.t_to_js x647 |])
    ;;

    module Line_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x649 : Ojs.t) -> x649
      and t_to_js : t -> Ojs.t = fun (x648 : Ojs.t) -> x648

      let create : ?attributes:Ojs.t -> ?class_:string -> unit -> t =
        fun ?attributes:(x650 : Ojs.t option) ?class_:(x651 : string option) () ->
        let x652 = Ojs.empty_obj () in
        (match x650 with
         | Some x654 -> Ojs.set_prop_ascii x652 "attributes" x654
         | None -> ());
        (match x651 with
         | Some x653 -> Ojs.set_prop_ascii x652 "class" (Ojs.string_to_js x653)
         | None -> ());
        t_of_js x652
      ;;
    end

    let line : Line_spec.t -> t =
      fun (x655 : Line_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "line"
           [| Line_spec.t_to_js x655 |])
    ;;
  end

  module Decoration_set = struct
    type t = Decoration.t State.Range_set.t

    let rec t_of_js : Ojs.t -> t =
      fun (x658 : Ojs.t) -> State.Range_set.t_of_js Decoration.t_of_js x658

    and t_to_js : t -> Ojs.t =
      fun (x656 : Decoration.t State.Range_set.t) ->
      State.Range_set.t_to_js Decoration.t_to_js x656
    ;;
  end

  module Editor_view = struct
    type t = editor_view

    let rec t_of_js : Ojs.t -> t = fun (x661 : Ojs.t) -> editor_view_of_js x661
    and t_to_js : t -> Ojs.t = fun (x660 : editor_view) -> editor_view_to_js x660

    let create : Config.t -> t =
      fun (x662 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           [| Config.t_to_js x662 |])
    ;;

    let dom : t -> Dom_html_element.t =
      fun (x663 : t) -> Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x663) "dom")
    ;;

    let content_dom : t -> Dom_html_element.t =
      fun (x664 : t) ->
      Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x664) "contentDOM")
    ;;

    let update_listener : (View_update.t -> unit) State.Facet.multi_out =
      State.Facet.multi_out_of_js
        (fun (x665 : Ojs.t) (x666 : View_update.t) ->
          ignore (Ojs.apply x665 [| View_update.t_to_js x666 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "updateListener")
    ;;

    let update : t -> State.Transaction.t list -> unit =
      fun (x669 : t) (x667 : State.Transaction.t list) ->
      ignore
        (Ojs.call
           (t_to_js x669)
           "update"
           [| Ojs.list_to_js State.Transaction.t_to_js x667 |])
    ;;

    let dispatch : t -> State.Transaction.t -> unit =
      fun (x671 : t) (x670 : State.Transaction.t) ->
      ignore (Ojs.call (t_to_js x671) "dispatch" [| State.Transaction.t_to_js x670 |])
    ;;

    let set_state : t -> State.Editor_state.t -> unit =
      fun (x673 : t) (x672 : State.Editor_state.t) ->
      ignore (Ojs.call (t_to_js x673) "setState" [| State.Editor_state.t_to_js x672 |])
    ;;

    let state : t -> State.Editor_state.t =
      fun (x674 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x674) "state")
    ;;

    let focus : t -> unit =
      fun (x675 : t) -> ignore (Ojs.call (t_to_js x675) "focus" [||])
    ;;

    let destroy : t -> unit =
      fun (x676 : t) -> ignore (Ojs.call (t_to_js x676) "destroy" [||])
    ;;

    let line_wrapping : State.Extension.t =
      State.Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "lineWrapping")
    ;;

    let editable : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "editable")
    ;;

    let dark_theme : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "darkTheme")
    ;;

    let decorations : (Decoration_set.t, Decoration_set.t) State.Facet.t =
      State.Facet.t_of_js
        Decoration_set.t_of_js
        Decoration_set.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let decorations'
      : ( (editor_view -> Decoration_set.t) Callback.t
          , (editor_view -> Decoration_set.t) Callback.t )
          State.Facet.t
      =
      State.Facet.t_of_js
        (fun (x683 : Ojs.t) ->
          Callback.t_of_js
            (fun (x684 : Ojs.t) (x685 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x684 [| editor_view_to_js x685 |]))
            x683)
        (fun (x686 : Ojs.t) ->
          Callback.t_of_js
            (fun (x687 : Ojs.t) (x688 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x687 [| editor_view_to_js x688 |]))
            x686)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    module Viewport = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x690 : Ojs.t) -> x690
      and t_to_js : t -> Ojs.t = fun (x689 : Ojs.t) -> x689

      let from : t -> int =
        fun (x691 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x691) "from")
      ;;

      let to_ : t -> int =
        fun (x692 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x692) "to")
      ;;
    end

    let viewport : t -> Viewport.t =
      fun (x693 : t) -> Viewport.t_of_js (Ojs.get_prop_ascii (t_to_js x693) "viewport")
    ;;

    module Scroll_into_view_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x695 : Ojs.t) -> x695
      and t_to_js : t -> Ojs.t = fun (x694 : Ojs.t) -> x694

      let create : ?y:string -> unit -> t =
        fun ?y:(x696 : string option) () ->
        let x697 = Ojs.empty_obj () in
        (match x696 with
         | Some x698 -> Ojs.set_prop_ascii x697 "y" (Ojs.string_to_js x698)
         | None -> ());
        t_of_js x697
      ;;
    end

    let scroll_into_view
      : pos:int -> ?options:Scroll_into_view_options.t -> unit -> State.State_effect.t
      =
      fun ~pos:(x699 : int) ?options:(x700 : Scroll_into_view_options.t option) () ->
      State.State_effect.t_of_js
        (let x703 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x703 "scrollIntoView")
           "apply"
           [| x703
            ; (let x701 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x701 "push" [| Ojs.int_to_js x699 |]);
               (match x700 with
                | Some x702 ->
                  ignore
                    (Ojs.call x701 "push" [| Scroll_into_view_options.t_to_js x702 |])
                | None -> ());
               x701)
           |])
    ;;

    module Theme_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x705 : Ojs.t) -> x705
      and t_to_js : t -> Ojs.t = fun (x704 : Ojs.t) -> x704

      let create : ?dark:bool -> unit -> t =
        fun ?dark:(x706 : bool option) () ->
        let x707 = Ojs.empty_obj () in
        (match x706 with
         | Some x708 -> Ojs.set_prop_ascii x707 "dark" (Ojs.bool_to_js x708)
         | None -> ());
        t_of_js x707
      ;;
    end

    let theme : spec:Ojs.t -> ?options:Theme_options.t -> unit -> State.Extension.t =
      fun ~spec:(x709 : Ojs.t) ?options:(x710 : Theme_options.t option) () ->
      State.Extension.t_of_js
        (let x713 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x713 "theme")
           "apply"
           [| x713
            ; (let x711 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x711 "push" [| x709 |]);
               (match x710 with
                | Some x712 ->
                  ignore (Ojs.call x711 "push" [| Theme_options.t_to_js x712 |])
                | None -> ());
               x711)
           |])
    ;;
  end

  module Plugin_value = struct
    type 'v t =
      { update : (View_update.t -> unit) option
      ; custom_state : 'v
      }

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x717 : Ojs.t) ->
      { update =
          Ojs.option_of_js
            (fun (x718 : Ojs.t) (x719 : View_update.t) ->
              ignore (Ojs.apply x718 [| View_update.t_to_js x719 |]))
            (Ojs.get_prop_ascii x717 "update")
      ; custom_state = __v_of_js (Ojs.get_prop_ascii x717 "customState")
      }

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x714 : __v t) ->
      Ojs.obj
        [| ( "update"
           , Ojs.option_to_js
               (fun (x715 : View_update.t -> unit) ->
                 Ojs.fun_to_js 1 (fun (x716 : Ojs.t) -> x715 (View_update.t_of_js x716)))
               x714.update )
         ; "customState", __v_to_js x714.custom_state
        |]
    ;;
  end

  module Plugin_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x721 : Ojs.t) -> x721

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x720 : Ojs.t) -> x720
    ;;

    let create : decorations:('v Plugin_value.t -> Decoration_set.t) option -> 'v t =
      fun ~decorations:(x722 : ('v Plugin_value.t -> Decoration_set.t) option) ->
      let x723 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x723
        "decorations"
        (Ojs.option_to_js
           (fun (x725 : 'v Plugin_value.t -> Decoration_set.t) ->
             Ojs.fun_to_js 1 (fun (x726 : Ojs.t) ->
               Decoration_set.t_to_js (x725 (Plugin_value.t_of_js Obj.magic x726))))
           x722);
      t_of_js Obj.magic x723
    ;;
  end

  module View_plugin = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x729 : Ojs.t) -> x729

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x728 : Ojs.t) -> x728
    ;;

    let extension : 'v t -> State.Extension.t =
      fun (x730 : 'v t) ->
      State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x730) "extension")
    ;;

    let define
      :  create:(Editor_view.t -> 'v Plugin_value.t) -> ?spec:'v Plugin_spec.t -> unit
      -> 'v t
      =
      fun ~create:(x732 : Editor_view.t -> 'v Plugin_value.t)
        ?spec:(x733 : 'v Plugin_spec.t option)
        () ->
      t_of_js
        Obj.magic
        (let x739 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "ViewPlugin"
         in
         Ojs.call
           (Ojs.get_prop_ascii x739 "define")
           "apply"
           [| x739
            ; (let x734 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore
                 (Ojs.call
                    x734
                    "push"
                    [| Ojs.fun_to_js 1 (fun (x737 : Ojs.t) ->
                         Plugin_value.t_to_js Obj.magic (x732 (Editor_view.t_of_js x737)))
                    |]);
               (match x733 with
                | Some x735 ->
                  ignore (Ojs.call x734 "push" [| Plugin_spec.t_to_js Obj.magic x735 |])
                | None -> ());
               x734)
           |])
    ;;
  end

  module Match_decorator = struct
    module Config = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x742 : Ojs.t) -> x742
      and t_to_js : t -> Ojs.t = fun (x741 : Ojs.t) -> x741

      let create
        :  regexp:RegExp.t -> ?decoration:Decoration.t
        -> ?decorate:
             (add:(from:int -> to_:int -> Decoration.t -> unit)
              -> from:int
              -> to_:int
              -> string option list
              -> Editor_view.t
              -> unit)
        -> ?max_length:int -> unit -> t
        =
        fun ~regexp:(x743 : RegExp.t)
          ?decoration:(x744 : Decoration.t option)
          ?decorate:
            (x745 :
               (add:(from:int -> to_:int -> Decoration.t -> unit)
                -> from:int
                -> to_:int
                -> string option list
                -> Editor_view.t
                -> unit)
                 option)
          ?max_length:(x746 : int option)
          () ->
        let x747 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x747 "regexp" (RegExp.t_to_js x743);
        (match x744 with
         | Some x760 -> Ojs.set_prop_ascii x747 "decoration" (Decoration.t_to_js x760)
         | None -> ());
        (match x745 with
         | Some x749 ->
           Ojs.set_prop_ascii
             x747
             "decorate"
             (Ojs.fun_to_js
                5
                (fun
                    (x750 : Ojs.t)
                    (x754 : Ojs.t)
                    (x755 : Ojs.t)
                    (x756 : Ojs.t)
                    (x759 : Ojs.t)
                  ->
                   x749
                     ~add:
                       (fun
                         ~from:(x751 : int) ~to_:(x752 : int) (x753 : Decoration.t) ->
                       ignore
                         (Ojs.apply
                            x750
                            [| Ojs.int_to_js x751
                             ; Ojs.int_to_js x752
                             ; Decoration.t_to_js x753
                            |]))
                     ~from:(Ojs.int_of_js x754)
                     ~to_:(Ojs.int_of_js x755)
                     (Ojs.list_of_js
                        (fun (x757 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x757)
                        x756)
                     (Editor_view.t_of_js x759)))
         | None -> ());
        (match x746 with
         | Some x748 -> Ojs.set_prop_ascii x747 "maxLength" (Ojs.int_to_js x748)
         | None -> ());
        t_of_js x747
      ;;
    end

    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x762 : Ojs.t) -> x762
    and t_to_js : t -> Ojs.t = fun (x761 : Ojs.t) -> x761

    let create : Config.t -> t =
      fun (x763 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "MatchDecorator")
           [| Config.t_to_js x763 |])
    ;;

    let create_deco : t -> Editor_view.t -> Decoration_set.t =
      fun (x765 : t) (x764 : Editor_view.t) ->
      Decoration_set.t_of_js
        (Ojs.call (t_to_js x765) "createDeco" [| Editor_view.t_to_js x764 |])
    ;;
  end

  module Command = struct
    type t = Editor_view.t -> bool

    let rec t_of_js : Ojs.t -> t =
      fun (x768 : Ojs.t) (x769 : Editor_view.t) ->
      Ojs.bool_of_js (Ojs.apply x768 [| Editor_view.t_to_js x769 |])

    and t_to_js : t -> Ojs.t =
      fun (x766 : Editor_view.t -> bool) ->
      Ojs.fun_to_js 1 (fun (x767 : Ojs.t) ->
        Ojs.bool_to_js (x766 (Editor_view.t_of_js x767)))
    ;;
  end

  module Key_binding = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x771 : Ojs.t) -> x771
    and t_to_js : t -> Ojs.t = fun (x770 : Ojs.t) -> x770

    let create
      :  ?key:string -> ?mac:string -> ?win:string -> ?linux:string -> run:Command.t
      -> ?shift:Command.t -> ?scope:string -> ?prevent_default:bool -> unit -> t
      =
      fun ?key:(x772 : string option)
        ?mac:(x773 : string option)
        ?win:(x774 : string option)
        ?linux:(x775 : string option)
        ~run:(x776 : Command.t)
        ?shift:(x777 : Command.t option)
        ?scope:(x778 : string option)
        ?prevent_default:(x779 : bool option)
        () ->
      let x780 = Ojs.empty_obj () in
      (match x772 with
       | Some x787 -> Ojs.set_prop_ascii x780 "key" (Ojs.string_to_js x787)
       | None -> ());
      (match x773 with
       | Some x786 -> Ojs.set_prop_ascii x780 "mac" (Ojs.string_to_js x786)
       | None -> ());
      (match x774 with
       | Some x785 -> Ojs.set_prop_ascii x780 "win" (Ojs.string_to_js x785)
       | None -> ());
      (match x775 with
       | Some x784 -> Ojs.set_prop_ascii x780 "linux" (Ojs.string_to_js x784)
       | None -> ());
      Ojs.set_prop_ascii x780 "run" (Command.t_to_js x776);
      (match x777 with
       | Some x783 -> Ojs.set_prop_ascii x780 "shift" (Command.t_to_js x783)
       | None -> ());
      (match x778 with
       | Some x782 -> Ojs.set_prop_ascii x780 "scope" (Ojs.string_to_js x782)
       | None -> ());
      (match x779 with
       | Some x781 -> Ojs.set_prop_ascii x780 "preventDefault" (Ojs.bool_to_js x781)
       | None -> ());
      t_of_js x780
    ;;
  end

  let keymap : Key_binding.t list State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x788 : Ojs.t) -> Ojs.list_of_js Key_binding.t_of_js x788)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "keymap")
  ;;
end

module Autocomplete = struct
  module Completion = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x791 : Ojs.t) -> x791
    and t_to_js : t -> Ojs.t = fun (x790 : Ojs.t) -> x790

    let create
      :  label:string -> ?detail:string
      -> ?info:[ `Str of string | `Dom of t -> Dom_html_element.t ] -> ?type_:string
      -> ?boost:int -> ?apply:string -> unit -> t
      =
      fun ~label:(x792 : string)
        ?detail:(x793 : string option)
        ?info:(x794 : [ `Str of string | `Dom of t -> Dom_html_element.t ] option)
        ?type_:(x795 : string option)
        ?boost:(x796 : int option)
        ?apply:(x797 : string option)
        () ->
      let x798 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x798 "label" (Ojs.string_to_js x792);
      (match x793 with
       | Some x806 -> Ojs.set_prop_ascii x798 "detail" (Ojs.string_to_js x806)
       | None -> ());
      (match x794 with
       | Some x802 ->
         Ojs.set_prop_ascii
           x798
           "info"
           (match x802 with
            | `Str x803 -> Ojs.string_to_js x803
            | `Dom x804 ->
              Ojs.fun_to_js 1 (fun (x805 : Ojs.t) ->
                Dom_html_element.t_to_js (x804 (t_of_js x805))))
       | None -> ());
      (match x795 with
       | Some x801 -> Ojs.set_prop_ascii x798 "type" (Ojs.string_to_js x801)
       | None -> ());
      (match x796 with
       | Some x800 -> Ojs.set_prop_ascii x798 "boost" (Ojs.int_to_js x800)
       | None -> ());
      (match x797 with
       | Some x799 -> Ojs.set_prop_ascii x798 "apply" (Ojs.string_to_js x799)
       | None -> ());
      t_of_js x798
    ;;

    let label : t -> string =
      fun (x807 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x807) "label")
    ;;

    let type_ : t -> string option =
      fun (x808 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x808) "type")
    ;;
  end

  module CompletionContext = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x811 : Ojs.t) -> x811
    and t_to_js : t -> Ojs.t = fun (x810 : Ojs.t) -> x810

    let state : t -> State.Editor_state.t =
      fun (x812 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x812) "state")
    ;;

    let pos : t -> int =
      fun (x813 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x813) "pos")
    ;;

    let explicit : t -> bool =
      fun (x814 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x814) "explicit")
    ;;
  end

  module CompletionResult = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x816 : Ojs.t) -> x816
    and t_to_js : t -> Ojs.t = fun (x815 : Ojs.t) -> x815

    let create
      :  from:int -> ?to_:int -> options:Completion.t list
      -> ?valid_for:
           [ `Regex of RegExp.t
           | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
           ]
      -> ?filter:bool -> unit -> t
      =
      fun ~from:(x817 : int)
        ?to_:(x818 : int option)
        ~options:(x819 : Completion.t list)
        ?valid_for:
          (x820 :
             [ `Regex of RegExp.t
             | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
             ]
               option)
        ?filter:(x821 : bool option)
        () ->
      let x822 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x822 "from" (Ojs.int_to_js x817);
      (match x818 with
       | Some x832 -> Ojs.set_prop_ascii x822 "to" (Ojs.int_to_js x832)
       | None -> ());
      Ojs.set_prop_ascii x822 "options" (Ojs.list_to_js Completion.t_to_js x819);
      (match x820 with
       | Some x824 ->
         Ojs.set_prop_ascii
           x822
           "validFor"
           (match x824 with
            | `Regex x825 -> RegExp.t_to_js x825
            | `Fn x826 ->
              Ojs.fun_to_js
                4
                (fun (x827 : Ojs.t) (x828 : Ojs.t) (x829 : Ojs.t) (x830 : Ojs.t) ->
                   Ojs.bool_to_js
                     (x826
                        (Ojs.string_of_js x827)
                        ~from:(Ojs.int_of_js x828)
                        ~to_:(Ojs.int_of_js x829)
                        (State.Editor_state.t_of_js x830))))
       | None -> ());
      (match x821 with
       | Some x823 -> Ojs.set_prop_ascii x822 "filter" (Ojs.bool_to_js x823)
       | None -> ());
      t_of_js x822
    ;;
  end

  module CompletionSource = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x834 : Ojs.t) -> x834
    and t_to_js : t -> Ojs.t = fun (x833 : Ojs.t) -> x833

    let of_sync_fun : (CompletionContext.t -> CompletionResult.t) -> t =
      fun (x835 : CompletionContext.t -> CompletionResult.t) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x836 : Ojs.t) ->
           CompletionResult.t_to_js (x835 (CompletionContext.t_of_js x836))))
    ;;

    let of_promise_fun
      : (CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) -> t
      =
      fun (x837 : CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x838 : Ojs.t) ->
           Ojs.option_to_js
             (fun (x839 : (CompletionResult.t, 'e) Promise.t) ->
               Promise.t_to_js CompletionResult.t_to_js Obj.magic x839)
             (x837 (CompletionContext.t_of_js x838))))
    ;;
  end

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x843 : Ojs.t) -> x843
    and t_to_js : t -> Ojs.t = fun (x842 : Ojs.t) -> x842

    module Add_to_options_parameters = struct
      type t =
        { render : Completion.t -> State.Editor_state.t -> Dom_html_element.t option
        ; position : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x848 : Ojs.t) ->
        { render =
            (fun (x849 : Completion.t) (x850 : State.Editor_state.t) ->
              Ojs.option_of_js
                Dom_html_element.t_of_js
                (Ojs.apply
                   (Ojs.get_prop_ascii x848 "render")
                   [| Completion.t_to_js x849; State.Editor_state.t_to_js x850 |]))
        ; position = Ojs.int_of_js (Ojs.get_prop_ascii x848 "position")
        }

      and t_to_js : t -> Ojs.t =
        fun (x844 : t) ->
        Ojs.obj
          [| ( "render"
             , Ojs.fun_to_js 2 (fun (x845 : Ojs.t) (x846 : Ojs.t) ->
                 Ojs.option_to_js
                   Dom_html_element.t_to_js
                   (x844.render
                      (Completion.t_of_js x845)
                      (State.Editor_state.t_of_js x846))) )
           ; "position", Ojs.int_to_js x844.position
          |]
      ;;
    end

    let create
      :  ?activate_on_typing:bool -> ?override:CompletionSource.t list
      -> ?max_rendered_options:int -> ?default_keymap:bool -> ?icons:bool
      -> ?add_to_options:Add_to_options_parameters.t list -> unit -> t
      =
      fun ?activate_on_typing:(x852 : bool option)
        ?override:(x853 : CompletionSource.t list option)
        ?max_rendered_options:(x854 : int option)
        ?default_keymap:(x855 : bool option)
        ?icons:(x856 : bool option)
        ?add_to_options:(x857 : Add_to_options_parameters.t list option)
        () ->
      let x858 = Ojs.empty_obj () in
      (match x852 with
       | Some x866 -> Ojs.set_prop_ascii x858 "activateOnTyping" (Ojs.bool_to_js x866)
       | None -> ());
      (match x853 with
       | Some x864 ->
         Ojs.set_prop_ascii x858 "override" (Ojs.list_to_js CompletionSource.t_to_js x864)
       | None -> ());
      (match x854 with
       | Some x863 -> Ojs.set_prop_ascii x858 "maxRenderedOptions" (Ojs.int_to_js x863)
       | None -> ());
      (match x855 with
       | Some x862 -> Ojs.set_prop_ascii x858 "defaultKeymap" (Ojs.bool_to_js x862)
       | None -> ());
      (match x856 with
       | Some x861 -> Ojs.set_prop_ascii x858 "icons" (Ojs.bool_to_js x861)
       | None -> ());
      (match x857 with
       | Some x859 ->
         Ojs.set_prop_ascii
           x858
           "addToOptions"
           (Ojs.list_to_js Add_to_options_parameters.t_to_js x859)
       | None -> ());
      t_of_js x858
    ;;
  end

  module Move_completion_selection_by = struct
    type t =
      | Option
      | Page

    let rec t_of_js : Ojs.t -> t =
      fun (x868 : Ojs.t) ->
      let x869 = x868 in
      match Ojs.string_of_js x869 with
      | "option" -> Option
      | "page" -> Page
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x867 : t) ->
      match x867 with
      | Option -> Ojs.string_to_js "option"
      | Page -> Ojs.string_to_js "page"
    ;;
  end

  let autocompletion : Config.t -> State.Extension.t =
    fun (x870 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "autocompletion"
         [| Config.t_to_js x870 |])
  ;;

  let completion_status : State.Editor_state.t -> string option =
    fun (x871 : State.Editor_state.t) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionStatus"
         [| State.Editor_state.t_to_js x871 |])
  ;;

  let start_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "startCompletion")
  ;;

  let close_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "closeCompletion")
  ;;

  let accept_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "acceptCompletion")
  ;;

  let move_completion_selection
    : forward:bool -> ?by:Move_completion_selection_by.t -> unit -> View.Command.t
    =
    fun ~forward:(x873 : bool) ?by:(x874 : Move_completion_selection_by.t option) () ->
    View.Command.t_of_js
      (let x877 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete"
       in
       Ojs.call
         (Ojs.get_prop_ascii x877 "moveCompletionSelection")
         "apply"
         [| x877
          ; (let x875 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore (Ojs.call x875 "push" [| Ojs.bool_to_js x873 |]);
             (match x874 with
              | Some x876 ->
                ignore
                  (Ojs.call x875 "push" [| Move_completion_selection_by.t_to_js x876 |])
              | None -> ());
             x875)
         |])
  ;;

  let completion_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionKeymap")
  ;;
end

module Commands = struct
  let standard_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "standardKeymap")
  ;;

  let default_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "defaultKeymap")
  ;;

  let emacs_style_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "emacsStyleKeymap")
  ;;

  let cursor_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharLeft")
  ;;

  let select_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharLeft")
  ;;

  let cursor_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupLeft")
  ;;

  let select_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupLeft")
  ;;

  let cursor_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharRight")
  ;;

  let select_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharRight")
  ;;

  let cursor_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupRight")
  ;;

  let select_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupRight")
  ;;

  let cursor_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineUp")
  ;;

  let select_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineUp")
  ;;

  let cursor_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineDown")
  ;;

  let select_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineDown")
  ;;

  let cursor_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageUp")
  ;;

  let select_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageUp")
  ;;

  let cursor_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageDown")
  ;;

  let select_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageDown")
  ;;

  let cursor_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryBackward")
  ;;

  let select_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryBackward")
  ;;

  let cursor_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocStart")
  ;;

  let select_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocStart")
  ;;

  let cursor_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryForward")
  ;;

  let select_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryForward")
  ;;

  let cursor_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocEnd")
  ;;

  let select_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocEnd")
  ;;

  let insert_newline_and_indent : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertNewlineAndIndent")
  ;;

  let select_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectAll")
  ;;

  let delete_char_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharBackward")
  ;;

  let delete_char_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharForward")
  ;;

  let delete_group_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupBackward")
  ;;

  let delete_group_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupForward")
  ;;

  let cursor_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxLeft")
  ;;

  let select_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxLeft")
  ;;

  let cursor_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxRight")
  ;;

  let select_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxRight")
  ;;

  let move_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineUp")
  ;;

  let copy_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineUp")
  ;;

  let move_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineDown")
  ;;

  let copy_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineDown")
  ;;

  let simplify_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "simplifySelection")
  ;;

  let select_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLine")
  ;;

  let select_parent_syntax : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectParentSyntax")
  ;;

  let indent_less : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentLess")
  ;;

  let indent_more : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentMore")
  ;;

  let indent_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentSelection")
  ;;

  let delete_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteLine")
  ;;

  let cursor_matching_bracket : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorMatchingBracket")
  ;;

  let toggle_comment : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "toggleComment")
  ;;
end

module Gutter = struct
  module Block_info = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x883 : Ojs.t) -> x883
    and t_to_js : t -> Ojs.t = fun (x882 : Ojs.t) -> x882

    let from : t -> int =
      fun (x884 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x884) "from")
    ;;

    let length : t -> int =
      fun (x885 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x885) "length")
    ;;

    let top : t -> int =
      fun (x886 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x886) "top")
    ;;

    let height : t -> int =
      fun (x887 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x887) "height")
    ;;

    let to_ : t -> int =
      fun (x888 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x888) "to")
    ;;

    let bottom : t -> int =
      fun (x889 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x889) "bottom")
    ;;
  end

  module Line_numbers_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x891 : Ojs.t) -> x891
    and t_to_js : t -> Ojs.t = fun (x890 : Ojs.t) -> x890

    module Dom_event_handlers = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x893 : Ojs.t) -> x893
      and t_to_js : t -> Ojs.t = fun (x892 : Ojs.t) -> x892

      let create : ?mousedown:(View.Editor_view.t -> Block_info.t -> unit) -> unit -> t =
        fun ?mousedown:(x894 : (View.Editor_view.t -> Block_info.t -> unit) option) () ->
        let x895 = Ojs.empty_obj () in
        (match x894 with
         | Some x896 ->
           Ojs.set_prop_ascii
             x895
             "mousedown"
             (Ojs.fun_to_js 2 (fun (x897 : Ojs.t) (x898 : Ojs.t) ->
                x896 (View.Editor_view.t_of_js x897) (Block_info.t_of_js x898)))
         | None -> ());
        t_of_js x895
      ;;
    end

    let create
      :  ?format_number:(int -> State.Editor_state.t -> string)
      -> ?dom_event_handlers:Dom_event_handlers.t -> unit -> t
      =
      fun ?format_number:(x899 : (int -> State.Editor_state.t -> string) option)
        ?dom_event_handlers:(x900 : Dom_event_handlers.t option)
        () ->
      let x901 = Ojs.empty_obj () in
      (match x899 with
       | Some x903 ->
         Ojs.set_prop_ascii
           x901
           "formatNumber"
           (Ojs.fun_to_js 2 (fun (x904 : Ojs.t) (x905 : Ojs.t) ->
              Ojs.string_to_js
                (x903 (Ojs.int_of_js x904) (State.Editor_state.t_of_js x905))))
       | None -> ());
      (match x900 with
       | Some x902 ->
         Ojs.set_prop_ascii x901 "domEventHandlers" (Dom_event_handlers.t_to_js x902)
       | None -> ());
      t_of_js x901
    ;;
  end

  let line_numbers : Line_numbers_config.t -> State.Extension.t =
    fun (x906 : Line_numbers_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "lineNumbers"
         [| Line_numbers_config.t_to_js x906 |])
  ;;

  let highlight_active_line_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLineGutter"
         [||])
  ;;
end

module History = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x908 : Ojs.t) -> x908
    and t_to_js : t -> Ojs.t = fun (x907 : Ojs.t) -> x907

    let create : ?min_depth:int -> ?new_group_delay:int -> unit -> t =
      fun ?min_depth:(x909 : int option) ?new_group_delay:(x910 : int option) () ->
      let x911 = Ojs.empty_obj () in
      (match x909 with
       | Some x913 -> Ojs.set_prop_ascii x911 "minDepth" (Ojs.int_to_js x913)
       | None -> ());
      (match x910 with
       | Some x912 -> Ojs.set_prop_ascii x911 "newGroupDelay" (Ojs.int_to_js x912)
       | None -> ());
      t_of_js x911
    ;;
  end

  let history : Config.t -> State.Extension.t =
    fun (x914 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "history"
         [| Config.t_to_js x914 |])
  ;;

  let undo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undo")
  ;;

  let redo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redo")
  ;;

  let undo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undoSelection")
  ;;

  let redo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redoSelection")
  ;;
end

module Search = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x916 : Ojs.t) -> x916
    and t_to_js : t -> Ojs.t = fun (x915 : Ojs.t) -> x915

    let create : ?top:bool -> ?match_case:bool -> unit -> t =
      fun ?top:(x917 : bool option) ?match_case:(x918 : bool option) () ->
      let x919 = Ojs.empty_obj () in
      (match x917 with
       | Some x921 -> Ojs.set_prop_ascii x919 "top" (Ojs.bool_to_js x921)
       | None -> ());
      (match x918 with
       | Some x920 -> Ojs.set_prop_ascii x919 "matchCase" (Ojs.bool_to_js x920)
       | None -> ());
      t_of_js x919
    ;;
  end

  let search : Config.t -> State.Extension.t =
    fun (x922 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "search"
         [| Config.t_to_js x922 |])
  ;;

  let find_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findNext")
  ;;

  let find_previous : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findPrevious")
  ;;

  let select_matches : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "selectMatches")
  ;;

  let replace_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceNext")
  ;;

  let replace_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceAll")
  ;;

  let open_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "openSearchPanel")
  ;;

  let close_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "closeSearchPanel")
  ;;

  let goto_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "gotoLine")
  ;;
end

module Basic_setup = struct
  let basic_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "basicSetup")
  ;;
end

module Language = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x924 : Ojs.t) -> x924
  and t_to_js : t -> Ojs.t = fun (x923 : Ojs.t) -> x923

  let extension : t -> State.Extension.t =
    fun (x925 : t) ->
    State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js x925) "extension")
  ;;
end

module Stream_parser = struct
  module String_stream = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x927 : Ojs.t) -> x927
    and t_to_js : t -> Ojs.t = fun (x926 : Ojs.t) -> x926

    let new_string_stream : string:string -> tab_size:int -> indent_unit:int -> t =
      fun ~string:(x928 : string) ~tab_size:(x929 : int) ~indent_unit:(x930 : int) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StringStream")
           [| Ojs.string_to_js x928; Ojs.int_to_js x929; Ojs.int_to_js x930 |])
    ;;

    let pos : t -> int =
      fun (x931 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x931) "pos")
    ;;

    let set_pos : t -> int -> unit =
      fun (x932 : t) (x933 : int) ->
      Ojs.set_prop_ascii (t_to_js x932) "pos" (Ojs.int_to_js x933)
    ;;

    let start : t -> int =
      fun (x934 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x934) "start")
    ;;

    let string : t -> string =
      fun (x935 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x935) "string")
    ;;

    let eol : t -> bool =
      fun (x936 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x936) "eol" [||])
    ;;

    let sol : t -> bool =
      fun (x937 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x937) "sol" [||])
    ;;

    let peek : t -> string option =
      fun (x938 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x938) "peek" [||])
    ;;

    let next : t -> string option =
      fun (x940 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x940) "next" [||])
    ;;

    let current : t -> string =
      fun (x942 : t) -> Ojs.string_of_js (Ojs.call (t_to_js x942) "current" [||])
    ;;

    let skip_to_end : t -> unit =
      fun (x943 : t) -> ignore (Ojs.call (t_to_js x943) "skipToEnd" [||])
    ;;

    let eat_space : t -> bool =
      fun (x944 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x944) "eatSpace" [||])
    ;;

    let eat : t -> match_:string -> string option =
      fun (x946 : t) ~match_:(x945 : string) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x946) "eat" [| Ojs.string_to_js x945 |])
    ;;

    let eat_regex : t -> match_:RegExp.t -> string option =
      fun (x949 : t) ~match_:(x948 : RegExp.t) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x949) "eat" [| RegExp.t_to_js x948 |])
    ;;

    let eat_while : t -> match_:string -> bool =
      fun (x952 : t) ~match_:(x951 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x952) "eatWhile" [| Ojs.string_to_js x951 |])
    ;;

    let eat_while_regex : t -> match_:RegExp.t -> bool =
      fun (x954 : t) ~match_:(x953 : RegExp.t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x954) "eatWhile" [| RegExp.t_to_js x953 |])
    ;;

    let match_
      : t -> pattern:string -> ?consume:bool -> ?case_insensitive:bool -> unit -> bool
      =
      fun (x961 : t)
        ~pattern:(x955 : string)
        ?consume:(x956 : bool option)
        ?case_insensitive:(x957 : bool option)
        () ->
      Ojs.bool_of_js
        (let x962 = t_to_js x961 in
         Ojs.call
           (Ojs.get_prop_ascii x962 "match")
           "apply"
           [| x962
            ; (let x958 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x958 "push" [| Ojs.string_to_js x955 |]);
               (match x956 with
                | Some x960 -> ignore (Ojs.call x958 "push" [| Ojs.bool_to_js x960 |])
                | None -> ());
               (match x957 with
                | Some x959 -> ignore (Ojs.call x958 "push" [| Ojs.bool_to_js x959 |])
                | None -> ());
               x958)
           |])
    ;;

    let match_regex
      :  t -> pattern:RegExp.t -> ?consume:bool -> ?case_insensitive:bool -> unit
      -> string list option
      =
      fun (x969 : t)
        ~pattern:(x963 : RegExp.t)
        ?consume:(x964 : bool option)
        ?case_insensitive:(x965 : bool option)
        () ->
      Ojs.option_of_js
        (fun (x971 : Ojs.t) -> Ojs.list_of_js Ojs.string_of_js x971)
        (let x970 = t_to_js x969 in
         Ojs.call
           (Ojs.get_prop_ascii x970 "match")
           "apply"
           [| x970
            ; (let x966 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               ignore (Ojs.call x966 "push" [| RegExp.t_to_js x963 |]);
               (match x964 with
                | Some x968 -> ignore (Ojs.call x966 "push" [| Ojs.bool_to_js x968 |])
                | None -> ());
               (match x965 with
                | Some x967 -> ignore (Ojs.call x966 "push" [| Ojs.bool_to_js x967 |])
                | None -> ());
               x966)
           |])
    ;;
  end

  module Stream_parser = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x974 : Ojs.t) -> x974
    and t_to_js : t -> Ojs.t = fun (x973 : Ojs.t) -> x973

    let create
      :  ?language_data:Ojs.t -> start_state:(unit -> 'state)
      -> token:(String_stream.t -> 'state -> string option) -> unit -> t
      =
      fun ?language_data:(x975 : Ojs.t option)
        ~start_state:(x976 : unit -> 'state)
        ~token:(x977 : String_stream.t -> 'state -> string option)
        () ->
      let x978 = Ojs.empty_obj () in
      (match x975 with
       | Some x982 -> Ojs.set_prop_ascii x978 "languageData" x982
       | None -> ());
      Ojs.set_prop_ascii
        x978
        "startState"
        (Ojs.fun_to_js 1 (fun _ -> Obj.magic (x976 ())));
      Ojs.set_prop_ascii
        x978
        "token"
        (Ojs.fun_to_js 2 (fun (x979 : Ojs.t) (x980 : Ojs.t) ->
           Ojs.option_to_js
             Ojs.string_to_js
             (x977 (String_stream.t_of_js x979) (Obj.magic x980))));
      t_of_js x978
    ;;
  end

  module Stream_language = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x984 : Ojs.t) -> x984
    and t_to_js : t -> Ojs.t = fun (x983 : Ojs.t) -> x983

    let define : Stream_parser.t -> t =
      fun (x985 : Stream_parser.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StreamLanguage")
           "define"
           [| Stream_parser.t_to_js x985 |])
    ;;

    let to_language : t -> Language.t = fun (x986 : t) -> Language.t_of_js (t_to_js x986)
  end
end

module Mllike = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x988 : Ojs.t) -> x988
  and t_to_js : t -> Ojs.t = fun (x987 : Ojs.t) -> x987

  let ocaml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "oCaml")
  ;;

  let fsharp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "fSharp")
  ;;

  let sml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "sml")
  ;;
end

module Diff = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x990 : Ojs.t) -> x990
  and t_to_js : t -> Ojs.t = fun (x989 : Ojs.t) -> x989

  let diff : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_diff")
         "diff")
  ;;
end

module Commonlisp = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x992 : Ojs.t) -> x992
  and t_to_js : t -> Ojs.t = fun (x991 : Ojs.t) -> x991

  let common_lisp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_commonlisp")
         "commonLisp")
  ;;
end

module Scheme = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x994 : Ojs.t) -> x994
  and t_to_js : t -> Ojs.t = fun (x993 : Ojs.t) -> x993

  let scheme : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_scheme")
         "scheme")
  ;;
end

module Lezer_highlight = struct
  module Highlighter = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x996 : Ojs.t) -> x996
    and t_to_js : t -> Ojs.t = fun (x995 : Ojs.t) -> x995
  end

  module Tag = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x998 : Ojs.t) -> x998
    and t_to_js : t -> Ojs.t = fun (x997 : Ojs.t) -> x997
  end

  module Tags = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1000 : Ojs.t) -> x1000
    and t_to_js : t -> Ojs.t = fun (x999 : Ojs.t) -> x999

    let arithmetic_operator : t -> Tag.t =
      fun (x1001 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1001) "arithmeticOperator")
    ;;

    let bool : t -> Tag.t =
      fun (x1002 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1002) "bool")
    ;;

    let bracket : t -> Tag.t =
      fun (x1003 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1003) "bracket")
    ;;

    let comment : t -> Tag.t =
      fun (x1004 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1004) "comment")
    ;;

    let compare_operator : t -> Tag.t =
      fun (x1005 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1005) "compareOperator")
    ;;

    let content : t -> Tag.t =
      fun (x1006 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1006) "content")
    ;;

    let control_keyword : t -> Tag.t =
      fun (x1007 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1007) "controlKeyword")
    ;;

    let definition_keyword : t -> Tag.t =
      fun (x1008 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1008) "definitionKeyword")
    ;;

    let doc_comment : t -> Tag.t =
      fun (x1009 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1009) "docComment")
    ;;

    let invalid : t -> Tag.t =
      fun (x1010 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1010) "invalid")
    ;;

    let keyword : t -> Tag.t =
      fun (x1011 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1011) "keyword")
    ;;

    let literal : t -> Tag.t =
      fun (x1012 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1012) "literal")
    ;;

    let logic_operator : t -> Tag.t =
      fun (x1013 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1013) "logicOperator")
    ;;

    let macro_name : t -> Tag.t =
      fun (x1014 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1014) "macroName")
    ;;

    let name : t -> Tag.t =
      fun (x1015 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1015) "name")
    ;;

    let number : t -> Tag.t =
      fun (x1016 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1016) "number")
    ;;

    let operator : t -> Tag.t =
      fun (x1017 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1017) "operator")
    ;;

    let paren : t -> Tag.t =
      fun (x1018 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1018) "paren")
    ;;

    let punctuation : t -> Tag.t =
      fun (x1019 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1019) "punctuation")
    ;;

    let string : t -> Tag.t =
      fun (x1020 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1020) "string")
    ;;

    let type_name : t -> Tag.t =
      fun (x1021 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1021) "typeName")
    ;;
  end

  let tags : Tags.t =
    Tags.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "tags")
  ;;

  let class_highlighter : Highlighter.t =
    Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "classHighlighter")
  ;;
end

module Highlight = struct
  module Syntax_highlighting_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1023 : Ojs.t) -> x1023
    and t_to_js : t -> Ojs.t = fun (x1022 : Ojs.t) -> x1022

    let create : ?fallback:bool -> unit -> t =
      fun ?fallback:(x1024 : bool option) () ->
      let x1025 = Ojs.empty_obj () in
      (match x1024 with
       | Some x1026 -> Ojs.set_prop_ascii x1025 "fallback" (Ojs.bool_to_js x1026)
       | None -> ());
      t_of_js x1025
    ;;
  end

  module Highlight_style = struct
    let define : specs:Ojs.t list -> Lezer_highlight.Highlighter.t =
      fun ~specs:(x1027 : Ojs.t list) ->
      Lezer_highlight.Highlighter.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "HighlightStyle")
           "define"
           [| Ojs.list_to_js (fun (x1028 : Ojs.t) -> x1028) x1027 |])
    ;;
  end

  let syntax_highlighting
    :  Lezer_highlight.Highlighter.t -> ?options:Syntax_highlighting_options.t -> unit
    -> State.Extension.t
    =
    fun (x1029 : Lezer_highlight.Highlighter.t)
      ?options:(x1030 : Syntax_highlighting_options.t option)
      () ->
    State.Extension.t_of_js
      (let x1033 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1033 "syntaxHighlighting")
         "apply"
         [| x1033
          ; (let x1031 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             ignore
               (Ojs.call x1031 "push" [| Lezer_highlight.Highlighter.t_to_js x1029 |]);
             (match x1030 with
              | Some x1032 ->
                ignore
                  (Ojs.call x1031 "push" [| Syntax_highlighting_options.t_to_js x1032 |])
              | None -> ());
             x1031)
         |])
  ;;

  let default_highlight_style : Lezer_highlight.Highlighter.t =
    Lezer_highlight.Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "defaultHighlightStyle")
  ;;
end

module Folding = struct
  module Fold = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1035 : Ojs.t) -> x1035
    and t_to_js : t -> Ojs.t = fun (x1034 : Ojs.t) -> x1034

    let create : from:int -> to_:int -> t =
      fun ~from:(x1036 : int) ~to_:(x1037 : int) ->
      let x1038 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1038 "from" (Ojs.int_to_js x1036);
      Ojs.set_prop_ascii x1038 "to" (Ojs.int_to_js x1037);
      t_of_js x1038
    ;;
  end

  module Fold_service_callback = struct
    type t = State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option

    let rec t_of_js : Ojs.t -> t =
      fun (x1044 : Ojs.t)
        (x1045 : State.Editor_state.t)
        ~line_start:(x1046 : int)
        ~line_end:(x1047 : int) ->
      Ojs.option_of_js
        Fold.t_of_js
        (Ojs.apply
           x1044
           [| State.Editor_state.t_to_js x1045
            ; Ojs.int_to_js x1046
            ; Ojs.int_to_js x1047
           |])

    and t_to_js : t -> Ojs.t =
      fun (x1039 :
            State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option) ->
      Ojs.fun_to_js 3 (fun (x1040 : Ojs.t) (x1041 : Ojs.t) (x1042 : Ojs.t) ->
        Ojs.option_to_js
          Fold.t_to_js
          (x1039
             (State.Editor_state.t_of_js x1040)
             ~line_start:(Ojs.int_of_js x1041)
             ~line_end:(Ojs.int_of_js x1042)))
    ;;
  end

  let fold_service : (Fold_service_callback.t, Fold_service_callback.t) State.Facet.t =
    State.Facet.t_of_js
      Fold_service_callback.t_of_js
      Fold_service_callback.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldService")
  ;;

  let fold_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldGutter"
         [||])
  ;;
end

module Matchbrackets = struct
  let bracket_matching : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "bracketMatching"
         [||])
  ;;
end

module Lang_markdown = struct
  let markdown : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_markdown")
         "markdown"
         [||])
  ;;
end

module Lang_python = struct
  let python : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_python")
         "python"
         [||])
  ;;
end

module Lang_sql = struct
  module Sql_dialect_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1052 : Ojs.t) -> x1052
    and t_to_js : t -> Ojs.t = fun (x1051 : Ojs.t) -> x1051

    let create
      :  ?keywords:string -> ?builtin:string -> ?types:string -> ?backslash_escapes:string
      -> ?hash_comments:bool -> ?slash_comments:bool -> ?space_after_dashes:bool
      -> ?double_quoted_strings:bool -> ?char_set_casts:bool -> ?operator_chars:string
      -> ?special_var:string -> ?identifier_quotes:string -> unit -> t
      =
      fun ?keywords:(x1053 : string option)
        ?builtin:(x1054 : string option)
        ?types:(x1055 : string option)
        ?backslash_escapes:(x1056 : string option)
        ?hash_comments:(x1057 : bool option)
        ?slash_comments:(x1058 : bool option)
        ?space_after_dashes:(x1059 : bool option)
        ?double_quoted_strings:(x1060 : bool option)
        ?char_set_casts:(x1061 : bool option)
        ?operator_chars:(x1062 : string option)
        ?special_var:(x1063 : string option)
        ?identifier_quotes:(x1064 : string option)
        () ->
      let x1065 = Ojs.empty_obj () in
      (match x1053 with
       | Some x1077 -> Ojs.set_prop_ascii x1065 "keywords" (Ojs.string_to_js x1077)
       | None -> ());
      (match x1054 with
       | Some x1076 -> Ojs.set_prop_ascii x1065 "builtin" (Ojs.string_to_js x1076)
       | None -> ());
      (match x1055 with
       | Some x1075 -> Ojs.set_prop_ascii x1065 "types" (Ojs.string_to_js x1075)
       | None -> ());
      (match x1056 with
       | Some x1074 ->
         Ojs.set_prop_ascii x1065 "backslashEscapes" (Ojs.string_to_js x1074)
       | None -> ());
      (match x1057 with
       | Some x1073 -> Ojs.set_prop_ascii x1065 "hashComments" (Ojs.bool_to_js x1073)
       | None -> ());
      (match x1058 with
       | Some x1072 -> Ojs.set_prop_ascii x1065 "slashComments" (Ojs.bool_to_js x1072)
       | None -> ());
      (match x1059 with
       | Some x1071 -> Ojs.set_prop_ascii x1065 "spaceAfterDashes" (Ojs.bool_to_js x1071)
       | None -> ());
      (match x1060 with
       | Some x1070 ->
         Ojs.set_prop_ascii x1065 "doubleQuotedStrings" (Ojs.bool_to_js x1070)
       | None -> ());
      (match x1061 with
       | Some x1069 -> Ojs.set_prop_ascii x1065 "charSetCasts" (Ojs.bool_to_js x1069)
       | None -> ());
      (match x1062 with
       | Some x1068 -> Ojs.set_prop_ascii x1065 "operatorChars" (Ojs.string_to_js x1068)
       | None -> ());
      (match x1063 with
       | Some x1067 -> Ojs.set_prop_ascii x1065 "specialVar" (Ojs.string_to_js x1067)
       | None -> ());
      (match x1064 with
       | Some x1066 ->
         Ojs.set_prop_ascii x1065 "identifierQuotes" (Ojs.string_to_js x1066)
       | None -> ());
      t_of_js x1065
    ;;
  end

  module Sql_dialect = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1079 : Ojs.t) -> x1079
    and t_to_js : t -> Ojs.t = fun (x1078 : Ojs.t) -> x1078

    let define : spec:Sql_dialect_spec.t -> t =
      fun ~spec:(x1080 : Sql_dialect_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
              "SQLDialect")
           "define"
           [| Sql_dialect_spec.t_to_js x1080 |])
    ;;
  end

  module Sql_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1082 : Ojs.t) -> x1082
    and t_to_js : t -> Ojs.t = fun (x1081 : Ojs.t) -> x1081

    let create
      :  ?dialect:Sql_dialect.t -> ?upper_case_keywords:bool
      -> ?tables:Autocomplete.Completion.t list -> ?default_table:int -> ?schema:Ojs.t
      -> unit -> t
      =
      fun ?dialect:(x1083 : Sql_dialect.t option)
        ?upper_case_keywords:(x1084 : bool option)
        ?tables:(x1085 : Autocomplete.Completion.t list option)
        ?default_table:(x1086 : int option)
        ?schema:(x1087 : Ojs.t option)
        () ->
      let x1088 = Ojs.empty_obj () in
      (match x1083 with
       | Some x1094 -> Ojs.set_prop_ascii x1088 "dialect" (Sql_dialect.t_to_js x1094)
       | None -> ());
      (match x1084 with
       | Some x1093 -> Ojs.set_prop_ascii x1088 "upperCaseKeywords" (Ojs.bool_to_js x1093)
       | None -> ());
      (match x1085 with
       | Some x1091 ->
         Ojs.set_prop_ascii
           x1088
           "tables"
           (Ojs.list_to_js Autocomplete.Completion.t_to_js x1091)
       | None -> ());
      (match x1086 with
       | Some x1090 -> Ojs.set_prop_ascii x1088 "defaultTable" (Ojs.int_to_js x1090)
       | None -> ());
      (match x1087 with
       | Some x1089 -> Ojs.set_prop_ascii x1088 "schema" x1089
       | None -> ());
      t_of_js x1088
    ;;
  end

  let postgresql : Sql_dialect.t =
    Sql_dialect.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
         "PostgreSQL")
  ;;

  let sql : ?config:Sql_config.t -> unit -> Language.t =
    fun ?config:(x1095 : Sql_config.t option) () ->
    Language.t_of_js
      (let x1098 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1098 "sql")
         "apply"
         [| x1098
          ; (let x1096 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x1095 with
              | Some x1097 ->
                ignore (Ojs.call x1096 "push" [| Sql_config.t_to_js x1097 |])
              | None -> ());
             x1096)
         |])
  ;;
end

module Lang_html = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1100 : Ojs.t) -> x1100
  and t_to_js : t -> Ojs.t = fun (x1099 : Ojs.t) -> x1099

  let html : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_html")
         "html"
         [||])
  ;;
end

module Lang_css = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1102 : Ojs.t) -> x1102
  and t_to_js : t -> Ojs.t = fun (x1101 : Ojs.t) -> x1101

  let css : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_css")
         "css"
         [||])
  ;;
end

module Lang_javascript = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1104 : Ojs.t) -> x1104
  and t_to_js : t -> Ojs.t = fun (x1103 : Ojs.t) -> x1103

  let javascript : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lang_javascript")
         "javascript"
         [||])
  ;;
end

module Lang_php = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1106 : Ojs.t) -> x1106
  and t_to_js : t -> Ojs.t = fun (x1105 : Ojs.t) -> x1105

  let php : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_php")
         "php"
         [||])
  ;;
end

module Lang_rust = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1108 : Ojs.t) -> x1108
  and t_to_js : t -> Ojs.t = fun (x1107 : Ojs.t) -> x1107

  let rust : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_rust")
         "rust"
         [||])
  ;;
end

module Lang_xml = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1110 : Ojs.t) -> x1110
  and t_to_js : t -> Ojs.t = fun (x1109 : Ojs.t) -> x1109

  let xml : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_xml")
         "xml"
         [||])
  ;;
end

module Merge = struct
  module Unified_merge_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1112 : Ojs.t) -> x1112
    and t_to_js : t -> Ojs.t = fun (x1111 : Ojs.t) -> x1111

    let create_from_string
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> string -> t
      =
      fun ?highlight_changes:(x1113 : bool option)
        ?gutter:(x1114 : bool option)
        ?syntax_highlight_deletions:(x1115 : bool option)
        ?merge_controls:(x1116 : bool option)
        (x1117 : string) ->
      let x1118 = Ojs.empty_obj () in
      (match x1113 with
       | Some x1122 -> Ojs.set_prop_ascii x1118 "highlightChanges" (Ojs.bool_to_js x1122)
       | None -> ());
      (match x1114 with
       | Some x1121 -> Ojs.set_prop_ascii x1118 "gutter" (Ojs.bool_to_js x1121)
       | None -> ());
      (match x1115 with
       | Some x1120 ->
         Ojs.set_prop_ascii x1118 "syntaxHighlightDeletions" (Ojs.bool_to_js x1120)
       | None -> ());
      (match x1116 with
       | Some x1119 -> Ojs.set_prop_ascii x1118 "mergeControls" (Ojs.bool_to_js x1119)
       | None -> ());
      Ojs.set_prop_ascii x1118 "original" (Ojs.string_to_js x1117);
      t_of_js x1118
    ;;

    let create_from_text
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> Text.Text.t -> t
      =
      fun ?highlight_changes:(x1123 : bool option)
        ?gutter:(x1124 : bool option)
        ?syntax_highlight_deletions:(x1125 : bool option)
        ?merge_controls:(x1126 : bool option)
        (x1127 : Text.Text.t) ->
      let x1128 = Ojs.empty_obj () in
      (match x1123 with
       | Some x1132 -> Ojs.set_prop_ascii x1128 "highlightChanges" (Ojs.bool_to_js x1132)
       | None -> ());
      (match x1124 with
       | Some x1131 -> Ojs.set_prop_ascii x1128 "gutter" (Ojs.bool_to_js x1131)
       | None -> ());
      (match x1125 with
       | Some x1130 ->
         Ojs.set_prop_ascii x1128 "syntaxHighlightDeletions" (Ojs.bool_to_js x1130)
       | None -> ());
      (match x1126 with
       | Some x1129 -> Ojs.set_prop_ascii x1128 "mergeControls" (Ojs.bool_to_js x1129)
       | None -> ());
      Ojs.set_prop_ascii x1128 "original" (Text.Text.t_to_js x1127);
      t_of_js x1128
    ;;
  end

  let unified_merge_view : Unified_merge_config.t -> State.Extension.t =
    fun (x1133 : Unified_merge_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Merge")
         "unifiedMergeView"
         [| Unified_merge_config.t_to_js x1133 |])
  ;;
end
